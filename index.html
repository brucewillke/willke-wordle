<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
/>
<title>WillkeWorld Wordle Wonder</title>
<style>
  :root {
    --bg: #111;
    --fg: #f2f2f2;
    --muted: #aaa;
    --tile-bg: #222;
    --absent: #3a3a3c;
    --present: #b59f3b;
    --correct: #538d4e;
    --accent: #6ca0ff;
  }
  html, body { height: 100%; }
  body {
    margin: 0; background: var(--bg); color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    display: grid; grid-template-rows: auto 1fr auto;
  }
  header, footer { padding: 10px 14px; border-bottom: 1px solid #222; }
  footer { border-top: 1px solid #222; border-bottom: none; color: var(--muted); font-size: 12px; }
  .wrap { max-width: 560px; margin: 0 auto; padding: 12px; }
  .row { display: grid; gap: 4px; grid-template-columns: repeat(var(--len), 1fr); margin: 4px 0; }
  .tile {
    aspect-ratio: 1 / 1; background: var(--tile-bg); border: 2px solid #333;
    display: grid; place-items: center; font-weight: 700; font-size: clamp(16px, 3.5vw, 24px);
    text-transform: uppercase; border-radius: 6px;
  }
  .tile.absent { background: var(--absent); border-color: var(--absent); }
  .tile.present { background: var(--present); border-color: var(--present); color: #111; }
  .tile.correct { background: var(--correct); border-color: var(--correct); }
  .controls { 
    display: flex; gap: 8px; margin: 10px 0 4px; align-items: center; flex-wrap: wrap;
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
  }
  button, select {
    background: #1b1b1b; color: var(--fg); border: 1px solid #333; border-radius: 6px;
    padding: 8px 10px; cursor: pointer; font-weight: 600;
    min-height: 44px; /* iOS recommended touch target size */
    touch-action: manipulation; /* Prevents zoom on double-tap */
  }
  button.primary { background: var(--accent); color: #081424; border-color: transparent; }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .kbd { display: grid; gap: 6px; margin-top: 8px; }
  .kbd-row { display: grid; gap: 6px; grid-template-columns: repeat(20, 1fr); }
  .key { 
    grid-column: span 2; 
    min-height: 44px; /* Better touch targets */
    touch-action: manipulation; /* Prevents zoom on double-tap */
  }
  .key.wide { grid-column: span 3; }
  .key.state-absent { background: var(--absent); border-color: var(--absent); }
  .key.state-present { background: var(--present); border-color: var(--present); color: #111; }
  .key.state-correct { background: var(--correct); border-color: var(--correct); }
  .msg { min-height: 22px; color: var(--muted); margin: 6px 0 2px; font-weight: 500; }
  a { color: var(--accent); text-decoration: none; }
  .title { font-weight: 800; letter-spacing: .5px; }
  .hint { color: var(--muted); font-size: 12px; }
  .stats { display:flex; gap:12px; align-items:center; flex-wrap:wrap; font-size:13px; color:var(--muted); }
  .pill { background:#1b1b1b; border:1px solid #333; border-radius:999px; padding:4px 8px; color:#ddd; }
  .dialog-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:1000; padding:20px; box-sizing:border-box; }
  .dialog { background:var(--bg); border:2px solid #333; border-radius:12px; padding:24px; max-width:400px; width:90%; text-align:center; max-height:80vh; overflow-y:auto; }
  .dialog h2 { margin:0 0 16px; font-size:28px; }
  .dialog .win { color:var(--correct); }
  .dialog .lose { color:#ff6b6b; }
  .dialog .answer-word { font-size:32px; font-weight:800; margin:16px 0; letter-spacing:2px; }
  .dialog button { margin-top:20px; padding:12px 24px; font-size:16px; min-height:48px; }
  .dialog input { 
    margin:10px 0; padding:8px 12px; border:1px solid #333; border-radius:6px; 
    background:var(--tile-bg); color:var(--fg); font-size:16px; width:200px;
    /* Prevent zoom on iOS when focusing inputs */
    font-size: max(16px, 1em);
  }
  .name-display { color:var(--accent); font-weight:600; }
  .error-shake { animation: shake 0.5s ease-in-out; }
  @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
  
  /* Mobile-specific improvements */
  @media (max-width: 768px) {
    .msg { font-size: 14px; min-height: 30px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; }
    .dialog { font-size: 16px; }
    .dialog .answer-word { font-size: 28px; }
    .key { font-size: 14px; }
    .tile { font-size: clamp(14px, 4vw, 20px); }
    
    /* Force error message visibility on mobile */
    .msg.error-shake {
      background: #ff6b6b !important;
      color: white !important;
      font-size: 16px !important;
      padding: 12px !important;
      border: 3px solid #ffffff !important;
      box-shadow: 0 0 20px rgba(255, 107, 107, 0.8) !important;
      animation: shake 0.5s ease-in-out, flash 2s ease-in-out !important;
    }
    
    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <span class="title" id="appTitle">wxrdle lite</span>
    <span class="hint" id="puzzleMeta"></span>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="controls">
      <label>Length:
        <select id="lengthSelect"></select>
      </label>
      <label>Category:
        <select id="categorySelect"></select>
      </label>
      <button id="newDailyBtn">New daily</button>
      <button id="newRandomBtn">New random</button>
      <button id="shareBtn">Share</button>
      <button id="nameBtn">👤 Name</button>
      <button id="testBtn" style="background: #ff6b6b; color: white;">🧪 Test Alerts</button>
      <span class="hint">Type or use keyboard below.</span>
    </div>

    <div class="stats" id="stats"></div>

    <div id="board"></div>
    <div class="msg" id="msg"></div>

    <div class="kbd" id="kbd"></div>
  </div>
</main>

<footer>
  <div class="wrap">
  </div>
</footer>

<script>
(async function(){
  let cfg;
  try {
    cfg = await fetch('config.json').then(r => r.json());
  } catch (e) {
    console.error('Failed to load config.json:', e);
    cfg = { title: 'WillkeWorld Wordle Wonder', defaultWordLength: 5, maxGuesses: 6, mode: 'daily' };
  }
  document.getElementById('appTitle').textContent = cfg.title || 'WillkeWorld Wordle Wonder';

  // State
  let WORD_LEN = cfg.defaultWordLength ?? 5;
  let MAX_GUESSES = cfg.maxGuesses ?? 6;
  let MODE = cfg.mode === 'random' ? 'random' : 'daily';
  let CURRENT_CATEGORY = 'sports'; // Default category
  let CATEGORIES = {};
  let ANSWERS = [];
  let ALLOWED = new Set();
  let PUZZLE_ID = '';
  let ANSWER = '';
  let GUESSES = [];
  let LOCKED = false;

  // UI refs
  const board = document.getElementById('board');
  const msg = document.getElementById('msg');
  const kbd = document.getElementById('kbd');
  const meta = document.getElementById('puzzleMeta');
  const lenSel = document.getElementById('lengthSelect');
  const catSel = document.getElementById('categorySelect');
  const statsEl = document.getElementById('stats');

  // localStorage stats helpers
  const STATS_KEY = 'wxrdle-lite-stats';
  const USER_NAME_KEY = 'wxrdle-lite-username';
  
  function loadStats() {
    try { return JSON.parse(localStorage.getItem(STATS_KEY) || '{}'); } catch { return {}; }
  }
  function saveStats(s) {
    localStorage.setItem(STATS_KEY, JSON.stringify(s));
  }
  function loadUserName() {
    return localStorage.getItem(USER_NAME_KEY) || '';
  }
  function saveUserName(name) {
    localStorage.setItem(USER_NAME_KEY, name.trim());
  }
  function statsBucketKey(mode, len, category) {
    return `${mode}-${len}-${category}`; // daily-5-sports, random-6-history, etc.
  }
  function getBucket(stats, mode, len, category) {
    const key = statsBucketKey(mode, len, category);
    if (!stats[key]) stats[key] = { games:0, wins:0, streak:0, lastWinDate:'', lastPlayedPid:'' };
    return stats[key];
  }
  function todayISO() {
    const t = new Date();
    return new Date(Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate())).toISOString().slice(0,10);
  }
  function updateStatsUI() {
    const s = loadStats();
    const b = getBucket(s, 'daily', WORD_LEN, CURRENT_CATEGORY);
    const r = getBucket(s, 'random', WORD_LEN, CURRENT_CATEGORY);
    const userName = loadUserName();
    const greeting = userName ? `<span class="name-display">${userName}</span>'s Stats: ` : '';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    
    statsEl.innerHTML = `
      ${greeting}
      <span class="pill">${catName} Daily ${WORD_LEN}: G ${b.games} • W ${b.wins} • Streak ${b.streak}</span>
      <span class="pill">${catName} Random ${WORD_LEN}: G ${r.games} • W ${r.wins}</span>
    `;
  }

  // discover available categories and lengths
  CATEGORIES = {
    'sports': { name: 'Sports', description: 'Athletic terms and games' },
    'history': { name: 'US History', description: 'American historical terms' },
    'music': { name: 'Music', description: 'Musical terms and instruments' },
    'art': { name: 'Art', description: 'Artistic terms and techniques' },
    'literature': { name: 'Literature', description: 'Literary terms and authors' },
    'bible': { name: 'Bible', description: 'Biblical terms and names' }
  };

  const availCategories = [];
  const availLengths = new Set();
  
  console.log('Discovering available categories and word lengths...');
  
  for (const [catKey, catInfo] of Object.entries(CATEGORIES)) {
    let foundCategory = false;
    for (let l = 3; l <= 10; l++) {
      try {
        console.log(`Checking: words/${catKey}/answers-${l}.txt`);
        const res = await fetch(`words/${catKey}/answers-${l}.txt`, { 
          cache: 'no-store',
          mode: 'cors',
          method: 'HEAD' // Just check if file exists, don't download content
        });
        if (res.ok) {
          console.log(`✓ Found ${catKey} length ${l}`);
          foundCategory = true;
          availLengths.add(l);
        } else {
          console.log(`✗ ${catKey} length ${l}: HTTP ${res.status}`);
        }
      } catch (e) {
        console.log(`✗ ${catKey} length ${l}: ${e.message}`);
        // Category/length combo doesn't exist or server error - that's fine, continue
      }
    }
    if (foundCategory) {
      availCategories.push(catKey);
      console.log(`✓ Category ${catKey} (${catInfo.name}) is available`);
    } else {
      console.log(`✗ Category ${catKey} (${catInfo.name}) has no accessible word files`);
    }
  }

  const avail = Array.from(availLengths).sort((a, b) => a - b);
  
  console.log('Discovery complete:');
  console.log('Available categories:', availCategories);
  console.log('Available word lengths:', avail);
  
  if (avail.length === 0 || availCategories.length === 0) { 
    const errorMsg = `⚠️ Word files not accessible!
    
This could be due to:
• Server blocking .txt file access
• CORS restrictions on your web server
• File permission issues
• Network connectivity problems

Categories found: ${availCategories.length}
Word lengths found: ${avail.length}

Using emergency fallback mode...`;

    console.error('No word files accessible, using fallback mode');
    showErrorMessage(errorMsg);
    
    // Emergency fallback - provide basic functionality
    availCategories.push('fallback');
    CATEGORIES['fallback'] = { name: 'Emergency Mode', description: 'Basic word set' };
    avail.push(5, 6, 7);
    
    console.log('Emergency fallback activated');
  }

  // Set up category selector
  catSel.innerHTML = availCategories.map(cat => 
    `<option value="${cat}">${CATEGORIES[cat].name}</option>`
  ).join('');
  CURRENT_CATEGORY = availCategories.includes('sports') ? 'sports' : availCategories[0];
  catSel.value = CURRENT_CATEGORY;

  lenSel.innerHTML = avail.map(l => `<option value="${l}">${l}</option>`).join('');
  lenSel.value = String(avail.includes(WORD_LEN) ? WORD_LEN : avail[0]);

  lenSel.addEventListener('change', async () => { 
    WORD_LEN = Number(lenSel.value); 
    await loadLists(); 
    newPuzzle(MODE); 
    updateStatsUI(); 
  });
  
  catSel.addEventListener('change', async () => { 
    CURRENT_CATEGORY = catSel.value; 
    await loadLists(); 
    newPuzzle(MODE); 
    updateStatsUI(); 
  });

  document.getElementById('newDailyBtn').addEventListener('click', () => { MODE='daily'; newPuzzle('daily'); });
  document.getElementById('newRandomBtn').addEventListener('click', () => { MODE='random'; newPuzzle('random'); });
  document.getElementById('shareBtn').addEventListener('click', shareResult);
  document.getElementById('nameBtn').addEventListener('click', showNameDialog);
  
  // Test button for debugging notifications
  document.getElementById('testBtn').addEventListener('click', () => {
    console.log('🧪 Test button clicked');
    showErrorMessage('This is a test error message to verify notifications work!');
  });

  const rows = ['qwertyuiop','asdfghjkl','↵zxcvbnm⌫'];
  function renderKeyboard() {
    kbd.innerHTML = '';
    for (const r of rows) {
      const row = document.createElement('div'); row.className = 'kbd-row';
      for (const ch of r) {
        const b = document.createElement('button'); b.className = 'key'; if (ch==='↵'||ch==='⌫') b.classList.add('wide');
        b.textContent = ch;
        b.addEventListener('click', () => {
          if (ch==='↵') submitGuess();
          else if (ch==='⌫') backspace();
          else typeChar(ch);
        });
        row.appendChild(b);
      }
      kbd.appendChild(row);
    }
  }

  function updateKeyStates() {
    const states = {}; const rank = {absent:0,present:1,correct:2};
    for (const g of GUESSES) {
      if (g.length !== ANSWER.length) continue;
      const tiles = scoreGuess(ANSWER,g);
      tiles.forEach((s,i) => {
        const c = g[i];
        if (!(c in states) || rank[s] > rank[states[c]]) states[c] = s;
      });
    }
    for (const btn of kbd.querySelectorAll('.key')) {
      const c = btn.textContent;
      if (!c || c.length!==1 || !/[a-z]/.test(c)) continue;
      btn.classList.remove('state-absent','state-present','state-correct');
      if (states[c]) btn.classList.add('state-'+states[c]);
    }
  }

  function renderBoard() {
    board.style.setProperty('--len', WORD_LEN);
    board.innerHTML = '';
    for (let r = 0; r < MAX_GUESSES; r++) {
      const row = document.createElement('div'); 
      row.className = 'row';
      const guess = GUESSES[r] || '';
      const isDone = r < GUESSES.length - 1 || (r < GUESSES.length && guess.length === WORD_LEN && !LOCKED);
      const tiles = isDone ? scoreGuess(ANSWER, guess) : [];
      
      for (let c = 0; c < WORD_LEN; c++) {
        const t = document.createElement('div'); 
        t.className = 'tile';
        t.textContent = guess[c] ? guess[c].toUpperCase() : '';
        if (isDone && guess.length === WORD_LEN) t.classList.add(tiles[c]); 
        row.appendChild(t);
      }
      board.appendChild(row);
    }
  }

  function seedIndex(seedStr, modulo) {
    let h = 2166136261 >>> 0;
    for (let i=0;i<seedStr.length;i++){ h ^= seedStr.charCodeAt(i); h = Math.imul(h, 16777619) >>> 0; }
    return modulo ? (h % modulo) : 0;
  }

  async function loadLists() {
    console.log(`Loading word lists for ${CURRENT_CATEGORY} length ${WORD_LEN}`);
    
    try {
      // Try to load answers file
      console.log(`Fetching: words/${CURRENT_CATEGORY}/answers-${WORD_LEN}.txt`);
      const answersResponse = await fetch(`words/${CURRENT_CATEGORY}/answers-${WORD_LEN}.txt`, { 
        cache: 'no-store',
        mode: 'cors' // Explicitly request CORS
      });
      
      if (!answersResponse.ok) {
        throw new Error(`HTTP ${answersResponse.status}: ${answersResponse.statusText} for answers file`);
      }
      
      const answerText = await answersResponse.text();
      console.log(`Answers file loaded, ${answerText.length} characters`);
      
      // Try to load allowed words file (optional)
      let allowedText = '';
      try {
        console.log(`Fetching: words/${CURRENT_CATEGORY}/allowed-${WORD_LEN}.txt`);
        const allowedResponse = await fetch(`words/${CURRENT_CATEGORY}/allowed-${WORD_LEN}.txt`, { 
          cache: 'no-store',
          mode: 'cors'
        });
        
        if (allowedResponse.ok) {
          allowedText = await allowedResponse.text();
          console.log(`Allowed words file loaded, ${allowedText.length} characters`);
        } else {
          console.warn(`Allowed words file not accessible: HTTP ${allowedResponse.status}`);
        }
      } catch (allowedError) {
        console.warn('Could not load allowed words file:', allowedError.message);
      }
      
      const sanitize = (txt) => [...new Set(txt.split(/\r?\n/).map(s => s.trim().toLowerCase()).filter(s => s.length===WORD_LEN && /^[a-z]+$/.test(s)))];
      ANSWERS = sanitize(answerText);
      ALLOWED = new Set(sanitize(allowedText).concat(ANSWERS));
      
      console.log(`Successfully loaded ${ANSWERS.length} answers and ${ALLOWED.size} allowed words for ${CURRENT_CATEGORY} length ${WORD_LEN}`);
      
      if (ANSWERS.length === 0) {
        throw new Error('No valid answers found in file');
      }
      
      // Clear any previous error messages
      if (msg.textContent.includes('Failed to load')) {
        msg.textContent = '';
      }
      
    } catch (e) {
      console.error('Failed to load word lists:', e);
      
      // Show detailed error information
      const errorDetails = e.message || 'Unknown error';
      const errorMessage = `⚠️ Cannot load ${CATEGORIES[CURRENT_CATEGORY]?.name} ${WORD_LEN}-letter word lists. 
      
Server Error: ${errorDetails}

This might be due to:
• Server permissions blocking .txt files
• CORS (Cross-Origin) restrictions
• Network connectivity issues

Try refreshing the page or contact the site administrator.`;
      
      showErrorMessage(errorMessage);
      
      // Provide fallback - use a minimal word list to keep game functional
      console.log('Using emergency fallback word list');
      ANSWERS = ['hello', 'world', 'games', 'words', 'magic'].filter(w => w.length === WORD_LEN);
      if (ANSWERS.length === 0) {
        // Generate some basic words for the current length
        const fallbackWords = {
          5: ['hello', 'world', 'games', 'magic', 'flash', 'block', 'spark', 'swift'],
          6: ['wonder', 'bright', 'strong', 'simple', 'cosmic', 'blazer', 'frozen'],
          7: ['amazing', 'complex', 'freedom', 'journey', 'crystal', 'awesome'],
          8: ['magnetic', 'tropical', 'inspired', 'machines', 'galaxies'],
          9: ['wonderful', 'explosion', 'knowledge', 'adventures', 'sparkling'],
          10: ['incredible', 'mysterious', 'technology', 'imaginable', 'tremendous']
        };
        ANSWERS = fallbackWords[WORD_LEN] || ['error'.padEnd(WORD_LEN, 'x').slice(0, WORD_LEN)];
      }
      ALLOWED = new Set(ANSWERS);
      console.log(`Emergency fallback: ${ANSWERS.length} words available`);
    }
  }

  function getDailyPuzzleId() {
    const today = new Date();
    const iso = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate())).toISOString().slice(0,10);
    return `${iso}-${WORD_LEN}`;
  }

  function puzzleNumber(pid) {
    if (!pid.startsWith('20')) return '?';
    const epoch = new Date(cfg.dailyEpoch || '2024-01-01T00:00:00Z');
    const d = new Date(pid.slice(0,10)+'T00:00:00Z');
    const n = Math.floor((d - epoch) / 86400000);
    return n >= 0 ? n : '?';
  }

  function newPuzzle(mode) {
    GUESSES = []; LOCKED = false;
    let pid, idx;
    if (mode === 'random') {
      const rnd = Math.random().toString(36).slice(2,10);
      pid = `rnd-${rnd}-${WORD_LEN}-${CURRENT_CATEGORY}`;
      idx = seedIndex(`${rnd}:${WORD_LEN}:${CURRENT_CATEGORY}`, ANSWERS.length);
      console.log(`Random mode: rnd=${rnd}, category=${CURRENT_CATEGORY}, idx=${idx}, total=${ANSWERS.length}`);
    } else {
      pid = `${getDailyPuzzleId()}-${CURRENT_CATEGORY}`;
      idx = seedIndex(`${cfg.publicSeed}:${pid}`, ANSWERS.length);
      console.log(`Daily mode: pid=${pid}, seed=${cfg.publicSeed}, category=${CURRENT_CATEGORY}, idx=${idx}, total=${ANSWERS.length}`);
    }
    PUZZLE_ID = pid;
    ANSWER = ANSWERS[idx];
    console.log(`Selected answer: ${ANSWER} (index ${idx})`);
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    meta.textContent = ` • ${catName} • ${mode} • ${WORD_LEN}-letter • #${puzzleNumber(pid)}`;
    msg.textContent = '';
    renderBoard(); updateKeyStates();
    const s = loadStats(); getBucket(s, mode, WORD_LEN, CURRENT_CATEGORY); s[statsBucketKey(mode,WORD_LEN,CURRENT_CATEGORY)].lastPlayedPid = pid; saveStats(s); updateStatsUI();
  }

  function scoreGuess(answer, guess) {
    const n = answer.length, res = Array(n).fill('absent'), count = {};
    for (let i=0;i<n;i++) count[answer[i]] = (count[answer[i]]||0)+1;
    for (let i=0;i<n;i++) if (guess[i]===answer[i]) { res[i]='correct'; count[guess[i]]--; }
    for (let i=0;i<n;i++) if (res[i]!=='correct' && (count[guess[i]]||0)>0) { res[i]='present'; count[guess[i]]--; }
    return res;
  }

  function typeChar(ch) {
    if (LOCKED) return;
    if (!/^[a-z]$/i.test(ch)) return;
    
    // Always ensure we have a current guess row
    if (GUESSES.length === 0) {
      GUESSES.push('');
    }
    
    // If current row is full, create new row (unless we're at max guesses)
    if (GUESSES[GUESSES.length-1].length === WORD_LEN) {
      if (GUESSES.length >= MAX_GUESSES) return;
      GUESSES.push('');
    }
    
    const i = GUESSES.length-1;
    if (GUESSES[i].length < WORD_LEN) { 
      GUESSES[i] += ch.toLowerCase(); 
      renderBoard(); 
      
      // Check if word is now complete and provide feedback
      if (GUESSES[i].length === WORD_LEN) {
        console.log(`Word complete: "${GUESSES[i]}" - waiting for Enter key`);
        
        // Visual feedback that word is complete
        msg.textContent = `Word complete: "${GUESSES[i].toUpperCase()}" - Press ENTER ↵ to submit!`;
        msg.style.color = '#6ca0ff';
        msg.style.fontWeight = 'bold';
        msg.style.backgroundColor = 'rgba(108, 160, 255, 0.1)';
        msg.style.padding = '8px';
        msg.style.borderRadius = '6px';
        msg.style.border = '1px solid #6ca0ff';
        
        // Make the Enter key pulse to draw attention
        const enterKey = document.querySelector('.key');
        const enterKeys = document.querySelectorAll('.key');
        for (const key of enterKeys) {
          if (key.textContent === '↵') {
            key.style.animation = 'pulse 1s infinite';
            key.style.background = '#6ca0ff';
            key.style.color = '#081424';
            break;
          }
        }
        
        // Add pulse animation if not exists
        if (!document.getElementById('pulse-animation')) {
          const style = document.createElement('style');
          style.id = 'pulse-animation';
          style.textContent = `
            @keyframes pulse {
              0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(108, 160, 255, 0.7); }
              70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(108, 160, 255, 0); }
              100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(108, 160, 255, 0); }
            }
          `;
          document.head.appendChild(style);
        }
      } else {
        // Clear any previous completion messages
        if (msg.textContent.includes('Press ENTER')) {
          msg.textContent = '';
          msg.style.cssText = '';
          
          // Reset Enter key styling
          const enterKeys = document.querySelectorAll('.key');
          for (const key of enterKeys) {
            if (key.textContent === '↵') {
              key.style.animation = '';
              key.style.background = '';
              key.style.color = '';
              break;
            }
          }
        }
      }
    }
  }
  function backspace() {
    if (LOCKED || GUESSES.length === 0) return;
    const i = GUESSES.length - 1;
    if (GUESSES[i].length === 0) {
      // If current row is empty, remove it if it's not the only row
      if (GUESSES.length > 1) {
        GUESSES.pop();
      }
      return;
    }
    GUESSES[i] = GUESSES[i].slice(0, -1);
    renderBoard();
    
    // Clear completion message and styling when word becomes incomplete
    if (GUESSES[i].length < WORD_LEN && msg.textContent.includes('Press ENTER')) {
      msg.textContent = '';
      msg.style.cssText = '';
      
      // Reset Enter key styling
      const enterKeys = document.querySelectorAll('.key');
      for (const key of enterKeys) {
        if (key.textContent === '↵') {
          key.style.animation = '';
          key.style.background = '';
          key.style.color = '';
          break;
        }
      }
    }
  }

  function finalizeGame(won) {
    console.log('finalizeGame called with won:', won); // Debug
    LOCKED = true;
    const s = loadStats();
    const b = getBucket(s, MODE, WORD_LEN, CURRENT_CATEGORY);

    // Count games only once per puzzleId (avoid F5 spam)
    const alreadyCounted = b._countedPid === PUZZLE_ID;
    if (!alreadyCounted) {
      b.games += 1;
      b._countedPid = PUZZLE_ID;
    }

    if (won && !b._wonPid?.includes(PUZZLE_ID)) {
      b.wins += 1;
      const today = todayISO();
      // streak only applies to daily mode
      if (MODE === 'daily') {
        if (b.lastWinDate) {
          const prev = new Date(b.lastWinDate+'T00:00:00Z');
          const cur = new Date(today+'T00:00:00Z');
          const diff = Math.round((cur - prev)/86400000);
          b.streak = diff === 1 ? (b.streak+1) : (diff === 0 ? b.streak : 1);
        } else {
          b.streak = 1;
        }
        b.lastWinDate = today;
      }
      b._wonPid = (b._wonPid || []).concat(PUZZLE_ID);
    } else if (!won && MODE === 'daily') {
      // a loss breaks streak for daily if played today
      const today = todayISO();
      const pidDay = PUZZLE_ID.slice(0,10);
      if (pidDay === today) b.streak = 0;
    }

    saveStats(s);
    updateStatsUI();
    
    console.log('About to call showGameDialog with won:', won); // Debug
    // Show win/lose dialog
    showGameDialog(won);
  }

  function showGameDialog(won) {
    console.log('showGameDialog called with won:', won); // Debug
    
    // Remove any existing dialogs first
    const existingOverlay = document.querySelector('.dialog-overlay');
    if (existingOverlay) {
      console.log('Removing existing dialog'); // Debug
      existingOverlay.remove();
    }
    
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    
    const dialog = document.createElement('div');
    dialog.className = 'dialog';
    
    const userName = loadUserName();
    const personalGreeting = userName ? ` ${userName}` : '';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    
    console.log('Creating dialog content for', won ? 'win' : 'lose'); // Debug
    
    if (won) {
      dialog.innerHTML = `
        <h2 class="win">🎉 Congratulations${personalGreeting}!</h2>
        <p>You solved today's ${catName} Wordle!</p>
        <div class="answer-word">${ANSWER.toUpperCase()}</div>
        <p>Solved in ${GUESSES.length} guess${GUESSES.length === 1 ? '' : 'es'}!</p>
        <button id="continueBtn" style="font-size:18px; padding:12px 24px;">Continue</button>
      `;
    } else {
      dialog.innerHTML = `
        <h2 class="lose">😔 Game Over${personalGreeting}</h2>
        <p>Better luck next time!</p>
        <div class="answer-word">${ANSWER.toUpperCase()}</div>
        <p>The word was <strong>${ANSWER.toUpperCase()}</strong></p>
        <button id="continueBtn" style="font-size:18px; padding:12px 24px;">Try Again Tomorrow</button>
      `;
    }
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    console.log('Dialog added to DOM'); // Debug
    
    // Add click handler to the button
    const continueBtn = dialog.querySelector('#continueBtn');
    continueBtn.addEventListener('click', () => {
      console.log('Continue button clicked'); // Debug
      overlay.remove();
    });
    
    // Ensure dialog is visible on mobile
    setTimeout(() => {
      console.log('Scrolling dialog into view'); // Debug
      dialog.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Force focus on the button for mobile accessibility
      continueBtn.focus();
    }, 200);
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        console.log('Overlay clicked, closing dialog'); // Debug
        overlay.remove();
      }
    });
    
    // Close on Escape key
    const closeOnEscape = (e) => {
      if (e.key === 'Escape') {
        console.log('Escape pressed, closing dialog'); // Debug
        overlay.remove();
        document.removeEventListener('keydown', closeOnEscape);
      }
    };
    document.addEventListener('keydown', closeOnEscape);
    
    // Auto-close after 15 seconds if user doesn't interact (mobile fallback)
    const autoClose = setTimeout(() => {
      console.log('Auto-closing dialog after timeout'); // Debug
      if (document.body.contains(overlay)) {
        overlay.remove();
      }
    }, 15000);
    
    // Cancel auto-close if user clicks
    overlay.addEventListener('click', () => {
      clearTimeout(autoClose);
    });
    
    console.log('Dialog setup complete'); // Debug
    
    // Mobile fallback - Create GIANT full-screen notification 
    console.log('Creating GIANT mobile game completion notification'); // Debug
    setTimeout(() => {
      const alertMessage = won ? 
        `🎉 CONGRATULATIONS${personalGreeting}!<br><br>You solved today's ${catName} Wordle!<br><br><strong>${ANSWER.toUpperCase()}</strong><br><br>Solved in ${GUESSES.length} guess${GUESSES.length === 1 ? '' : 'es'}!` :
        `😔 GAME OVER${personalGreeting}<br><br>Better luck next time!<br><br>The word was:<br><strong>${ANSWER.toUpperCase()}</strong>`;
      
      const notification = document.createElement('div');
      notification.id = 'mobile-game-notification';
      notification.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        background: ${won ? 'rgba(76, 175, 80, 0.96)' : 'rgba(244, 67, 54, 0.96)'} !important;
        color: white !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        font-size: 24px !important;
        font-weight: bold !important;
        z-index: 99999 !important;
        text-align: center !important;
        padding: 40px !important;
        box-sizing: border-box !important;
        animation: slideIn 0.5s ease-out !important;
      `;
      
      // Add slide-in animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { opacity: 0; transform: scale(0.8); }
          to { opacity: 1; transform: scale(1); }
        }
      `;
      document.head.appendChild(style);
      
      notification.innerHTML = `
        <div style="
          background: white; 
          color: ${won ? '#4CAF50' : '#f44336'}; 
          padding: 40px; 
          border-radius: 25px; 
          max-width: 90vw; 
          font-size: 22px;
          border: 6px solid ${won ? '#4CAF50' : '#f44336'};
          box-shadow: 0 0 60px rgba(0,0,0,0.8);
          line-height: 1.5;
        ">
          ${alertMessage}
          <div style="margin-top: 30px; font-size: 18px; background: ${won ? '#4CAF50' : '#f44336'}; color: white; padding: 15px; border-radius: 15px;">
            🎯 TAP ANYWHERE TO CONTINUE 🎯
          </div>
        </div>
      `;
      
      // Remove any existing game notifications
      const existing = document.getElementById('mobile-game-notification');
      if (existing) existing.remove();
      
      document.body.appendChild(notification);
      console.log('GIANT mobile game notification added to DOM');
      
      // Click to close
      notification.addEventListener('click', () => {
        notification.remove();
        console.log('Giant mobile game notification clicked and removed');
      });
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (notification && notification.parentNode) {
          notification.remove();
          console.log('Giant mobile game notification auto-removed');
        }
      }, 10000);
      
      console.log('Giant game completion notification shown successfully');
    }, 500);
  }

  function showNameDialog() {
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    
    const dialog = document.createElement('div');
    dialog.className = 'dialog';
    
    const currentName = loadUserName();
    
    dialog.innerHTML = `
      <h2>👤 Enter Your Name</h2>
      <p>Personalize your WillkeWorld Wordle Wonder experience!</p>
      <input type="text" id="nameInput" placeholder="Enter your name" value="${currentName}" maxlength="20">
      <div>
        <button onclick="saveName()">Save Name</button>
        <button onclick="this.closest('.dialog-overlay').remove()" style="margin-left:10px;">Cancel</button>
      </div>
    `;
    
    // Make saveName function available globally for the onclick
    window.saveName = () => {
      const nameInput = document.getElementById('nameInput');
      const name = nameInput.value.trim();
      if (name) {
        saveUserName(name);
        updateStatsUI();
        overlay.remove();
        showErrorMessage(`Welcome, ${name}! 👋`);
      } else {
        nameInput.style.borderColor = '#ff6b6b';
        nameInput.focus();
      }
    };
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Focus the input
    setTimeout(() => {
      const input = document.getElementById('nameInput');
      input.focus();
      input.select();
    }, 100);
    
    // Handle Enter key in input
    dialog.querySelector('#nameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        window.saveName();
      } else if (e.key === 'Escape') {
        overlay.remove();
      }
    });
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
  }

  function showErrorMessage(message) {
    console.log('🚨 showErrorMessage called with:', message); // Enhanced debug
    
    // IMMEDIATE visual feedback - force browser attention
    document.title = '🚨 ERROR: ' + message;
    
    // Update the regular message area
    msg.textContent = message;
    msg.classList.add('error-shake');
    msg.style.color = '#ff6b6b !important'; // Make error more visible
    msg.style.backgroundColor = 'rgba(255, 107, 107, 0.9) !important'; // Stronger background
    msg.style.padding = '12px !important';
    msg.style.borderRadius = '8px !important';
    msg.style.fontWeight = 'bold !important';
    msg.style.fontSize = '16px !important'; // Larger text for mobile
    msg.style.border = '2px solid #ff6b6b !important'; // Border for visibility
    msg.style.zIndex = '999 !important'; // Ensure it's on top
    msg.style.position = 'relative !important';
    
    // Force visibility on mobile with multiple methods
    msg.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    // Mobile-specific: Force repaint
    msg.style.transform = 'translateZ(0)';
    msg.offsetHeight; // Force reflow
    
    // Try native alert as backup (in case DOM manipulation is being blocked)
    try {
      alert('🚨 ERROR: ' + message);
      console.log('✅ Native alert shown successfully');
    } catch (e) {
      console.log('❌ Native alert blocked:', e);
    }
    
    // SUPER PROMINENT mobile notification - takes up most of screen
    console.log('📱 Creating GIANT mobile notification overlay'); // Debug
    const notification = document.createElement('div');
    notification.id = 'mobile-notification';
    notification.className = 'emergency-notification'; // Add class for debugging
    notification.style.cssText = `
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      background: rgba(255, 68, 68, 0.98) !important;
      color: white !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      font-size: 28px !important;
      font-weight: bold !important;
      z-index: 999999 !important;
      text-align: center !important;
      padding: 40px !important;
      box-sizing: border-box !important;
      animation: errorPulse 1s infinite !important;
      cursor: pointer !important;
    `;
    
    // Add pulsing animation
    const style = document.createElement('style');
    style.id = 'error-animations';
    style.textContent = `
      @keyframes errorPulse {
        0% { opacity: 0.9; transform: scale(1); background: rgba(255, 68, 68, 0.98); }
        50% { opacity: 1; transform: scale(1.02); background: rgba(255, 100, 100, 0.98); }
        100% { opacity: 0.9; transform: scale(1); background: rgba(255, 68, 68, 0.98); }
      }
    `;
    if (!document.getElementById('error-animations')) {
      document.head.appendChild(style);
    }
    
    notification.innerHTML = `
      <div style="
        background: white; 
        color: #ff4444; 
        padding: 40px; 
        border-radius: 20px; 
        max-width: 90vw; 
        font-size: 26px;
        border: 6px solid #ff4444;
        box-shadow: 0 0 50px rgba(0,0,0,0.9);
        animation: bounce 0.6s ease-out;
      ">
        🚨 ERROR 🚨<br><br>
        ${message}
        <div style="margin-top: 25px; font-size: 18px; color: #666; background: #ffebee; padding: 15px; border-radius: 10px;">
          📱 TAP ANYWHERE TO DISMISS 📱
        </div>
      </div>
    `;
    
    // Remove any existing notifications
    const existing = document.getElementById('mobile-notification');
    if (existing) {
      console.log('🗑️ Removing existing notification');
      existing.remove();
    }
    
    document.body.appendChild(notification);
    console.log('✅ GIANT mobile notification added to DOM, element:', notification);
    console.log('✅ Notification parent:', notification.parentNode);
    console.log('✅ Notification computed style:', window.getComputedStyle(notification).display);
    
    // Multiple ways to ensure visibility
    notification.scrollIntoView({ behavior: 'instant', block: 'center' });
    
    // Click to dismiss
    notification.addEventListener('click', () => {
      console.log('👆 Notification clicked, removing');
      notification.remove();
      document.title = 'WillkeWorld Wordle Wonder'; // Reset title
    });
    
    // Keyboard dismiss
    const dismissOnKey = (e) => {
      console.log('⌨️ Key pressed, dismissing notification');
      notification.remove();
      document.title = 'WillkeWorld Wordle Wonder'; // Reset title
      document.removeEventListener('keydown', dismissOnKey);
    };
    document.addEventListener('keydown', dismissOnKey);
    
    // Auto-remove after 6 seconds (longer for readability)
    setTimeout(() => {
      if (notification && notification.parentNode) {
        console.log('⏱️ Auto-removing notification after timeout');
        notification.remove();
        document.title = 'WillkeWorld Wordle Wonder'; // Reset title
      }
    }, 6000);
    
    setTimeout(() => {
      msg.classList.remove('error-shake');
      msg.style.cssText = ''; // Reset all styles at once
    }, 7000); // Longer duration for mobile
    
    console.log('🎯 showErrorMessage function complete');
  }

  function submitGuess() {
    console.log('submitGuess called, LOCKED:', LOCKED, 'GUESSES.length:', GUESSES.length); // Debug
    if (LOCKED || GUESSES.length === 0) return;
    const i = GUESSES.length - 1;
    const g = GUESSES[i];
    
    console.log('Submitting guess:', g, 'length:', g.length, 'required:', WORD_LEN); // Debug
    
    // Must have exactly WORD_LEN letters
    if (g.length !== WORD_LEN) { 
      console.log('Not enough letters'); // Debug
      showErrorMessage('Not enough letters.');
      return; 
    }
    
    console.log('Checking if allowed:', g, 'in set:', ALLOWED.has(g)); // Debug
    
    // Must be a valid dictionary word
    if (!ALLOWED.has(g)) { 
      console.log('Invalid word detected:', g); // Debug
      showErrorMessage(`"${g.toUpperCase()}" is not a valid word! Clearing...`);
      // Clear the invalid word immediately and re-render
      GUESSES[i] = '';
      console.log('Cleared guess, re-rendering'); // Debug
      renderBoard();
      // Force a brief pause to show the error message
      setTimeout(() => {
        console.log('Second render after clear'); // Debug
        renderBoard(); // Re-render to ensure UI is updated
      }, 200);
      return; 
    }

    console.log('Valid word, processing guess'); // Debug
    // Score the guess and update display
    const tiles = scoreGuess(ANSWER, g);
    renderBoard(); 
    updateKeyStates();
    const win = tiles.every(t => t === 'correct');

    console.log(`Guess ${GUESSES.length}: "${g}", Win: ${win}, Max: ${MAX_GUESSES}`);

    if (win) { 
      msg.textContent = 'You win! 🎉'; 
      console.log('Player won, calling finalizeGame(true)'); // Debug
      finalizeGame(true); 
      return; 
    }
    
    // Check if this was the last allowed guess
    if (GUESSES.length >= MAX_GUESSES) {
      console.log(`Game over! Final guess count: ${GUESSES.length}, Max: ${MAX_GUESSES}, Answer: ${ANSWER}`);
      msg.textContent = `Out of guesses. The word was ${ANSWER.toUpperCase()}.`;
      finalizeGame(false);
      return;
    }
    
    // Clear message for next guess
    msg.textContent = '';
  }

  async function shareResult() {
    if (GUESSES.length === 0) {
      msg.textContent = 'Play a game first before sharing!';
      return;
    }
    
    const rows = GUESSES.slice(0, Math.min(GUESSES.length, MAX_GUESSES));
    const squares = rows.map(g => scoreGuess(ANSWER,g).map(x => x==='correct'?'🟩': x==='present'?'🟨':'⬛').join('')).join('\n');
    const won = rows.length>0 && scoreGuess(ANSWER, rows[rows.length-1]).every(x=>x==='correct');
    const attempts = won ? rows.length : 'X';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    const text = [
      `${catName} Wordle ${puzzleNumber(PUZZLE_ID)} ${attempts}/${MAX_GUESSES}`,
      '',
      squares
    ].join('\n');
    
    console.log('Sharing text:', text);
    
    try {
      // Try modern clipboard API first
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text); 
        msg.textContent = 'Copied result to clipboard ✅ Ready to paste!'; 
        return;
      }
      
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      if (document.execCommand('copy')) {
        msg.textContent = 'Copied result to clipboard ✅ Ready to paste!';
      } else {
        throw new Error('execCommand failed');
      }
      document.body.removeChild(textArea);
      
    } catch (err) {
      console.error('Share failed:', err);
      msg.textContent = `Share failed. Try manually copying: ${text}`;
    }
  }

  // physical keyboard
  window.addEventListener('keydown', (e) => {
    // Don't handle keyboard events when a dialog is open or when typing in an input field
    if (document.querySelector('.dialog-overlay') || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return;
    }
    
    if (e.key==='Enter') {
      e.preventDefault(); // Prevent form submission on mobile
      submitGuess();
    }
    else if (e.key==='Backspace') {
      e.preventDefault(); // Prevent navigation on mobile
      backspace();
    }
    else if (/^[a-z]$/i.test(e.key)) typeChar(e.key);
  });

  // Mobile-specific touch event handling
  let touchStartY = 0;
  let touchEndY = 0;
  
  document.addEventListener('touchstart', (e) => {
    touchStartY = e.changedTouches[0].screenY;
  });
  
  document.addEventListener('touchend', (e) => {
    touchEndY = e.changedTouches[0].screenY;
    // Prevent pull-to-refresh on mobile
    if (touchStartY < touchEndY) {
      e.preventDefault();
    }
  });

  // boot
  renderKeyboard();
  await loadLists();
  newPuzzle(MODE);
  updateStatsUI();
  
  // Show name dialog on first visit if no name is set
  if (!loadUserName()) {
    setTimeout(() => {
      showNameDialog();
    }, 500); // Reduced delay from 1000ms to 500ms
  }
})();
</script>
</body>
</html>
