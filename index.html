<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
/>
<title>wxrdle lite</title>
<style>
  :root {
    --bg: #111;
    --fg: #f2f2f2;
    --muted: #aaa;
    --tile-bg: #222;
    --absent: #3a3a3c;
    --present: #b59f3b;
    --correct: #538d4e;
    --accent: #6ca0ff;
  }
  html, body { height: 100%; }
  body {
    margin: 0; background: var(--bg); color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    display: grid; grid-template-rows: auto 1fr auto;
  }
  header, footer { padding: 10px 14px; border-bottom: 1px solid #222; }
  footer { border-top: 1px solid #222; border-bottom: none; color: var(--muted); font-size: 12px; }
  .wrap { max-width: 560px; margin: 0 auto; padding: 12px; }
  .row { display: grid; gap: 6px; grid-template-columns: repeat(var(--len), 1fr); margin: 6px 0; }
  .tile {
    aspect-ratio: 1 / 1; background: var(--tile-bg); border: 2px solid #333;
    display: grid; place-items: center; font-weight: 700; font-size: clamp(18px, 4vw, 28px);
    text-transform: uppercase; border-radius: 6px;
  }
  .tile.absent { background: var(--absent); border-color: var(--absent); }
  .tile.present { background: var(--present); border-color: var(--present); color: #111; }
  .tile.correct { background: var(--correct); border-color: var(--correct); }
  .controls { display: flex; gap: 8px; margin: 10px 0 4px; align-items: center; flex-wrap: wrap; }
  button, select {
    background: #1b1b1b; color: var(--fg); border: 1px solid #333; border-radius: 6px;
    padding: 8px 10px; cursor: pointer; font-weight: 600;
  }
  button.primary { background: var(--accent); color: #081424; border-color: transparent; }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .kbd { display: grid; gap: 6px; margin-top: 8px; }
  .kbd-row { display: grid; gap: 6px; grid-template-columns: repeat(20, 1fr); }
  .key { grid-column: span 2; }
  .key.wide { grid-column: span 3; }
  .key.state-absent { background: var(--absent); border-color: var(--absent); }
  .key.state-present { background: var(--present); border-color: var(--present); color: #111; }
  .key.state-correct { background: var(--correct); border-color: var(--correct); }
  .msg { min-height: 22px; color: var(--muted); margin: 6px 0 2px; }
  a { color: var(--accent); text-decoration: none; }
  .title { font-weight: 800; letter-spacing: .5px; }
  .hint { color: var(--muted); font-size: 12px; }
  .stats { display:flex; gap:12px; align-items:center; flex-wrap:wrap; font-size:13px; color:var(--muted); }
  .pill { background:#1b1b1b; border:1px solid #333; border-radius:999px; padding:4px 8px; color:#ddd; }
  .dialog-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; z-index:1000; }
  .dialog { background:var(--bg); border:2px solid #333; border-radius:12px; padding:24px; max-width:400px; width:90%; text-align:center; }
  .dialog h2 { margin:0 0 16px; font-size:28px; }
  .dialog .win { color:var(--correct); }
  .dialog .lose { color:#ff6b6b; }
  .dialog .answer-word { font-size:32px; font-weight:800; margin:16px 0; letter-spacing:2px; }
  .dialog button { margin-top:20px; padding:12px 24px; font-size:16px; }
  .dialog input { margin:10px 0; padding:8px 12px; border:1px solid #333; border-radius:6px; background:var(--tile-bg); color:var(--fg); font-size:16px; width:200px; }
  .name-display { color:var(--accent); font-weight:600; }
  .error-shake { animation: shake 0.5s ease-in-out; }
  @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <span class="title" id="appTitle">wxrdle lite</span>
    <span class="hint" id="puzzleMeta"></span>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="controls">
      <label>Length:
        <select id="lengthSelect"></select>
      </label>
      <button id="newDailyBtn">New daily</button>
      <button id="newRandomBtn">New random</button>
      <button id="shareBtn">Share</button>
      <button id="nameBtn">ðŸ‘¤ Name</button>
      <span class="hint">Type or use keyboard below.</span>
    </div>

    <div class="stats" id="stats"></div>

    <div id="board"></div>
    <div class="msg" id="msg"></div>

    <div class="kbd" id="kbd"></div>
  </div>
</main>

<footer>
  <div class="wrap">
    Dictionary lives in <code>/words/*.txt</code>. Edit and push to customize. Hosted statically, no backend âœ¨
  </div>
</footer>

<script>
(async function(){
  let cfg;
  try {
    cfg = await fetch('config.json').then(r => r.json());
  } catch (e) {
    console.error('Failed to load config.json:', e);
    cfg = { title: 'wxrdle lite', defaultWordLength: 5, maxGuesses: 6, mode: 'daily' };
  }
  document.getElementById('appTitle').textContent = cfg.title || 'wxrdle lite';

  // State
  let WORD_LEN = cfg.defaultWordLength ?? 5;
  let MAX_GUESSES = cfg.maxGuesses ?? 6;
  let MODE = cfg.mode === 'random' ? 'random' : 'daily';
  let ANSWERS = [];
  let ALLOWED = new Set();
  let PUZZLE_ID = '';
  let ANSWER = '';
  let GUESSES = [];
  let LOCKED = false;

  // UI refs
  const board = document.getElementById('board');
  const msg = document.getElementById('msg');
  const kbd = document.getElementById('kbd');
  const meta = document.getElementById('puzzleMeta');
  const lenSel = document.getElementById('lengthSelect');
  const statsEl = document.getElementById('stats');

  // localStorage stats helpers
  const STATS_KEY = 'wxrdle-lite-stats';
  const USER_NAME_KEY = 'wxrdle-lite-username';
  
  function loadStats() {
    try { return JSON.parse(localStorage.getItem(STATS_KEY) || '{}'); } catch { return {}; }
  }
  function saveStats(s) {
    localStorage.setItem(STATS_KEY, JSON.stringify(s));
  }
  function loadUserName() {
    return localStorage.getItem(USER_NAME_KEY) || '';
  }
  function saveUserName(name) {
    localStorage.setItem(USER_NAME_KEY, name.trim());
  }
  function statsBucketKey(mode, len) {
    return `${mode}-${len}`; // daily-5, random-6, etc.
  }
  function getBucket(stats, mode, len) {
    const key = statsBucketKey(mode, len);
    if (!stats[key]) stats[key] = { games:0, wins:0, streak:0, lastWinDate:'', lastPlayedPid:'' };
    return stats[key];
  }
  function todayISO() {
    const t = new Date();
    return new Date(Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate())).toISOString().slice(0,10);
  }
  function updateStatsUI() {
    const s = loadStats();
    const b = getBucket(s, 'daily', WORD_LEN);
    const r = getBucket(s, 'random', WORD_LEN);
    const userName = loadUserName();
    const greeting = userName ? `<span class="name-display">${userName}</span>'s Stats: ` : '';
    
    statsEl.innerHTML = `
      ${greeting}
      <span class="pill">Daily ${WORD_LEN}: G ${b.games} â€¢ W ${b.wins} â€¢ Streak ${b.streak}</span>
      <span class="pill">Random ${WORD_LEN}: G ${r.games} â€¢ W ${r.wins}</span>
    `;
  }

  // discover available lengths
  const avail = [];
  for (let l=3; l<=10; l++) {
    try { 
      const res = await fetch(`words/answers-${l}.txt`, { cache:'no-store' }); 
      if (res.ok) avail.push(l); 
    } catch (e) {
      console.log(`No answers-${l}.txt file found`);
    }
  }
  if (avail.length === 0) { 
    msg.textContent = 'No word lists found. Add /words/answers-5.txt.'; 
    console.error('No word files found in /words/ directory');
    return; 
  }

  console.log('Available word lengths:', avail);

  lenSel.innerHTML = avail.map(l => `<option value="${l}">${l}</option>`).join('');
  lenSel.value = String(avail.includes(WORD_LEN) ? WORD_LEN : avail[0]);

  lenSel.addEventListener('change', async () => { WORD_LEN = Number(lenSel.value); await loadLists(); newPuzzle(MODE); updateStatsUI(); });

  document.getElementById('newDailyBtn').addEventListener('click', () => { MODE='daily'; newPuzzle('daily'); });
  document.getElementById('newRandomBtn').addEventListener('click', () => { MODE='random'; newPuzzle('random'); });
  document.getElementById('shareBtn').addEventListener('click', shareResult);
  document.getElementById('nameBtn').addEventListener('click', showNameDialog);

  const rows = ['qwertyuiop','asdfghjkl','â†µzxcvbnmâŒ«'];
  function renderKeyboard() {
    kbd.innerHTML = '';
    for (const r of rows) {
      const row = document.createElement('div'); row.className = 'kbd-row';
      for (const ch of r) {
        const b = document.createElement('button'); b.className = 'key'; if (ch==='â†µ'||ch==='âŒ«') b.classList.add('wide');
        b.textContent = ch;
        b.addEventListener('click', () => {
          if (ch==='â†µ') submitGuess();
          else if (ch==='âŒ«') backspace();
          else typeChar(ch);
        });
        row.appendChild(b);
      }
      kbd.appendChild(row);
    }
  }

  function updateKeyStates() {
    const states = {}; const rank = {absent:0,present:1,correct:2};
    for (const g of GUESSES) {
      if (g.length !== ANSWER.length) continue;
      const tiles = scoreGuess(ANSWER,g);
      tiles.forEach((s,i) => {
        const c = g[i];
        if (!(c in states) || rank[s] > rank[states[c]]) states[c] = s;
      });
    }
    for (const btn of kbd.querySelectorAll('.key')) {
      const c = btn.textContent;
      if (!c || c.length!==1 || !/[a-z]/.test(c)) continue;
      btn.classList.remove('state-absent','state-present','state-correct');
      if (states[c]) btn.classList.add('state-'+states[c]);
    }
  }

  function renderBoard() {
    board.style.setProperty('--len', WORD_LEN);
    board.innerHTML = '';
    for (let r = 0; r < MAX_GUESSES; r++) {
      const row = document.createElement('div'); 
      row.className = 'row';
      const guess = GUESSES[r] || '';
      const isDone = r < GUESSES.length - 1 || (r < GUESSES.length && guess.length === WORD_LEN && !LOCKED);
      const tiles = isDone ? scoreGuess(ANSWER, guess) : [];
      
      for (let c = 0; c < WORD_LEN; c++) {
        const t = document.createElement('div'); 
        t.className = 'tile';
        t.textContent = guess[c] ? guess[c].toUpperCase() : '';
        if (isDone && guess.length === WORD_LEN) t.classList.add(tiles[c]); 
        row.appendChild(t);
      }
      board.appendChild(row);
    }
  }

  function seedIndex(seedStr, modulo) {
    let h = 2166136261 >>> 0;
    for (let i=0;i<seedStr.length;i++){ h ^= seedStr.charCodeAt(i); h = Math.imul(h, 16777619) >>> 0; }
    return modulo ? (h % modulo) : 0;
  }

  async function loadLists() {
    try {
      const ans = await fetch(`words/answers-${WORD_LEN}.txt`, { cache:'no-store' }).then(r => r.text());
      const alw = await fetch(`words/allowed-${WORD_LEN}.txt`, { cache:'no-store' }).then(r => r.text()).catch(()=> '');
      const sanitize = (txt) => [...new Set(txt.split(/\r?\n/).map(s => s.trim().toLowerCase()).filter(s => s.length===WORD_LEN && /^[a-z]+$/.test(s)))];
      ANSWERS = sanitize(ans);
      ALLOWED = new Set(sanitize(alw).concat(ANSWERS));
      console.log(`Loaded ${ANSWERS.length} answers and ${ALLOWED.size} allowed words for length ${WORD_LEN}`);
    } catch (e) {
      console.error('Failed to load word lists:', e);
      msg.textContent = `Failed to load word lists for ${WORD_LEN}-letter words.`;
    }
  }

  function getDailyPuzzleId() {
    const today = new Date();
    const iso = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate())).toISOString().slice(0,10);
    return `${iso}-${WORD_LEN}`;
  }

  function puzzleNumber(pid) {
    if (!pid.startsWith('20')) return '?';
    const epoch = new Date(cfg.dailyEpoch || '2024-01-01T00:00:00Z');
    const d = new Date(pid.slice(0,10)+'T00:00:00Z');
    const n = Math.floor((d - epoch) / 86400000);
    return n >= 0 ? n : '?';
  }

  function newPuzzle(mode) {
    GUESSES = []; LOCKED = false;
    let pid, idx;
    if (mode === 'random') {
      const rnd = Math.random().toString(36).slice(2,10);
      pid = `rnd-${rnd}-${WORD_LEN}`;
      idx = seedIndex(`${rnd}:${WORD_LEN}`, ANSWERS.length);
      console.log(`Random mode: rnd=${rnd}, idx=${idx}, total=${ANSWERS.length}`);
    } else {
      pid = getDailyPuzzleId();
      idx = seedIndex(`${cfg.publicSeed}:${pid}`, ANSWERS.length);
      console.log(`Daily mode: pid=${pid}, seed=${cfg.publicSeed}, idx=${idx}, total=${ANSWERS.length}`);
    }
    PUZZLE_ID = pid;
    ANSWER = ANSWERS[idx];
    console.log(`Selected answer: ${ANSWER} (index ${idx})`);
    meta.textContent = ` â€¢ ${mode} â€¢ ${WORD_LEN}-letter â€¢ #${puzzleNumber(pid)}`;
    msg.textContent = '';
    renderBoard(); updateKeyStates();
    const s = loadStats(); getBucket(s, mode, WORD_LEN); s[statsBucketKey(mode,WORD_LEN)].lastPlayedPid = pid; saveStats(s); updateStatsUI();
  }

  function scoreGuess(answer, guess) {
    const n = answer.length, res = Array(n).fill('absent'), count = {};
    for (let i=0;i<n;i++) count[answer[i]] = (count[answer[i]]||0)+1;
    for (let i=0;i<n;i++) if (guess[i]===answer[i]) { res[i]='correct'; count[guess[i]]--; }
    for (let i=0;i<n;i++) if (res[i]!=='correct' && (count[guess[i]]||0)>0) { res[i]='present'; count[guess[i]]--; }
    return res;
  }

  function typeChar(ch) {
    if (LOCKED) return;
    if (!/^[a-z]$/i.test(ch)) return;
    
    // Always ensure we have a current guess row
    if (GUESSES.length === 0) {
      GUESSES.push('');
    }
    
    // If current row is full, create new row (unless we're at max guesses)
    if (GUESSES[GUESSES.length-1].length === WORD_LEN) {
      if (GUESSES.length >= MAX_GUESSES) return;
      GUESSES.push('');
    }
    
    const i = GUESSES.length-1;
    if (GUESSES[i].length < WORD_LEN) { 
      GUESSES[i] += ch.toLowerCase(); 
      renderBoard(); 
    }
  }
  function backspace() {
    if (LOCKED || GUESSES.length === 0) return;
    const i = GUESSES.length - 1;
    if (GUESSES[i].length === 0) {
      // If current row is empty, remove it if it's not the only row
      if (GUESSES.length > 1) {
        GUESSES.pop();
      }
      return;
    }
    GUESSES[i] = GUESSES[i].slice(0, -1);
    renderBoard();
  }

  function finalizeGame(won) {
    LOCKED = true;
    const s = loadStats();
    const b = getBucket(s, MODE, WORD_LEN);

    // Count games only once per puzzleId (avoid F5 spam)
    const alreadyCounted = b._countedPid === PUZZLE_ID;
    if (!alreadyCounted) {
      b.games += 1;
      b._countedPid = PUZZLE_ID;
    }

    if (won && !b._wonPid?.includes(PUZZLE_ID)) {
      b.wins += 1;
      const today = todayISO();
      // streak only applies to daily mode
      if (MODE === 'daily') {
        if (b.lastWinDate) {
          const prev = new Date(b.lastWinDate+'T00:00:00Z');
          const cur = new Date(today+'T00:00:00Z');
          const diff = Math.round((cur - prev)/86400000);
          b.streak = diff === 1 ? (b.streak+1) : (diff === 0 ? b.streak : 1);
        } else {
          b.streak = 1;
        }
        b.lastWinDate = today;
      }
      b._wonPid = (b._wonPid || []).concat(PUZZLE_ID);
    } else if (!won && MODE === 'daily') {
      // a loss breaks streak for daily if played today
      const today = todayISO();
      const pidDay = PUZZLE_ID.slice(0,10);
      if (pidDay === today) b.streak = 0;
    }

    saveStats(s);
    updateStatsUI();
    
    // Show win/lose dialog
    showGameDialog(won);
  }

  function showGameDialog(won) {
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    
    const dialog = document.createElement('div');
    dialog.className = 'dialog';
    
    const userName = loadUserName();
    const personalGreeting = userName ? ` ${userName}` : '';
    
    if (won) {
      dialog.innerHTML = `
        <h2 class="win">ðŸŽ‰ Congratulations${personalGreeting}!</h2>
        <p>You solved today's 1776 Wordle!</p>
        <div class="answer-word">${ANSWER.toUpperCase()}</div>
        <p>Solved in ${GUESSES.length} guess${GUESSES.length === 1 ? '' : 'es'}!</p>
        <button onclick="this.closest('.dialog-overlay').remove()">Continue</button>
      `;
    } else {
      dialog.innerHTML = `
        <h2 class="lose">ðŸ˜” Game Over${personalGreeting}</h2>
        <p>Better luck next time!</p>
        <div class="answer-word">${ANSWER.toUpperCase()}</div>
        <p>The word was <strong>${ANSWER.toUpperCase()}</strong></p>
        <button onclick="this.closest('.dialog-overlay').remove()">Try Again Tomorrow</button>
      `;
    }
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
    
    // Close on Escape key
    const closeOnEscape = (e) => {
      if (e.key === 'Escape') {
        overlay.remove();
        document.removeEventListener('keydown', closeOnEscape);
      }
    };
    document.addEventListener('keydown', closeOnEscape);
  }

  function showNameDialog() {
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    
    const dialog = document.createElement('div');
    dialog.className = 'dialog';
    
    const currentName = loadUserName();
    
    dialog.innerHTML = `
      <h2>ðŸ‘¤ Enter Your Name</h2>
      <p>Personalize your 1776 Wordle experience!</p>
      <input type="text" id="nameInput" placeholder="Enter your name" value="${currentName}" maxlength="20">
      <div>
        <button onclick="saveName()">Save Name</button>
        <button onclick="this.closest('.dialog-overlay').remove()" style="margin-left:10px;">Cancel</button>
      </div>
    `;
    
    // Make saveName function available globally for the onclick
    window.saveName = () => {
      const nameInput = document.getElementById('nameInput');
      const name = nameInput.value.trim();
      if (name) {
        saveUserName(name);
        updateStatsUI();
        overlay.remove();
        showErrorMessage(`Welcome, ${name}! ðŸ‘‹`);
      } else {
        nameInput.style.borderColor = '#ff6b6b';
        nameInput.focus();
      }
    };
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Focus the input
    setTimeout(() => {
      const input = document.getElementById('nameInput');
      input.focus();
      input.select();
    }, 100);
    
    // Handle Enter key in input
    dialog.querySelector('#nameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        window.saveName();
      } else if (e.key === 'Escape') {
        overlay.remove();
      }
    });
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
  }

  function showErrorMessage(message) {
    msg.textContent = message;
    msg.classList.add('error-shake');
    setTimeout(() => {
      msg.classList.remove('error-shake');
    }, 500);
  }

  function submitGuess() {
    if (LOCKED || GUESSES.length === 0) return;
    const i = GUESSES.length - 1;
    const g = GUESSES[i];
    
    // Must have exactly WORD_LEN letters
    if (g.length !== WORD_LEN) { 
      showErrorMessage('Not enough letters.');
      return; 
    }
    
    // Must be a valid dictionary word
    if (!ALLOWED.has(g)) { 
      showErrorMessage(`"${g.toUpperCase()}" is not in the word list!`);
      return; 
    }

    // Score the guess and update display
    const tiles = scoreGuess(ANSWER, g);
    renderBoard(); 
    updateKeyStates();
    const win = tiles.every(t => t === 'correct');

    console.log(`Guess ${GUESSES.length}: "${g}", Win: ${win}, Max: ${MAX_GUESSES}`);

    if (win) { 
      msg.textContent = 'You win! ðŸŽ‰'; 
      finalizeGame(true); 
      return; 
    }
    
    // Check if this was the last allowed guess
    if (GUESSES.length >= MAX_GUESSES) {
      console.log(`Game over! Final guess count: ${GUESSES.length}, Max: ${MAX_GUESSES}, Answer: ${ANSWER}`);
      msg.textContent = `Out of guesses. The word was ${ANSWER.toUpperCase()}.`;
      finalizeGame(false);
      return;
    }
    
    // Clear message for next guess
    msg.textContent = '';
  }

  async function shareResult() {
    if (GUESSES.length === 0) {
      msg.textContent = 'Play a game first before sharing!';
      return;
    }
    
    const rows = GUESSES.slice(0, Math.min(GUESSES.length, MAX_GUESSES));
    const squares = rows.map(g => scoreGuess(ANSWER,g).map(x => x==='correct'?'ðŸŸ©': x==='present'?'ðŸŸ¨':'â¬›').join('')).join('\n');
    const won = rows.length>0 && scoreGuess(ANSWER, rows[rows.length-1]).every(x=>x==='correct');
    const attempts = won ? rows.length : 'X';
    const text = [
      `1776 Wordle ${puzzleNumber(PUZZLE_ID)} ${attempts}/${MAX_GUESSES}`,
      '',
      squares
    ].join('\n');
    
    console.log('Sharing text:', text);
    
    try {
      // Try modern clipboard API first
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text); 
        msg.textContent = 'Copied result to clipboard âœ… Ready to paste!'; 
        return;
      }
      
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      if (document.execCommand('copy')) {
        msg.textContent = 'Copied result to clipboard âœ… Ready to paste!';
      } else {
        throw new Error('execCommand failed');
      }
      document.body.removeChild(textArea);
      
    } catch (err) {
      console.error('Share failed:', err);
      msg.textContent = `Share failed. Try manually copying: ${text}`;
    }
  }

  // physical keyboard
  window.addEventListener('keydown', (e) => {
    if (e.key==='Enter') submitGuess();
    else if (e.key==='Backspace') backspace();
    else if (/^[a-z]$/i.test(e.key)) typeChar(e.key);
  });

  // boot
  renderKeyboard();
  await loadLists();
  newPuzzle(MODE);
  updateStatsUI();
  
  // Show name dialog on first visit if no name is set
  if (!loadUserName()) {
    setTimeout(() => {
      showNameDialog();
    }, 1000);
  }
})();
</script>
</body>
</html>
