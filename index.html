<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
/>
<title>WillkeWorld Wordle Wonder</title>
<style>
  :root {
    --bg: #111;
    --fg: #f2f2f2;
    --muted: #aaa;
    --tile-bg: #222;
    --absent: #3a3a3c;
    --present: #b59f3b;
    --correct: #538d4e;
    --accent: #6ca0ff;
  }
  html, body { height: 100%; }
  body {
    margin: 0; background: var(--bg); color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    display: grid; grid-template-rows: auto 1fr auto;
  }
  header, footer { padding: 10px 14px; border-bottom: 1px solid #222; }
  footer { border-top: 1px solid #222; border-bottom: none; color: var(--muted); font-size: 12px; }
  .wrap { max-width: 560px; margin: 0 auto; padding: 12px; }
  .row { display: grid; gap: 4px; grid-template-columns: repeat(var(--len), 1fr); margin: 4px 0; }
  .tile {
    aspect-ratio: 1 / 1; background: var(--tile-bg); border: 2px solid #333;
    display: grid; place-items: center; font-weight: 700; font-size: clamp(16px, 3.5vw, 24px);
    text-transform: uppercase; border-radius: 6px;
  }
  .tile.absent { background: var(--absent); border-color: var(--absent); }
  .tile.present { background: var(--present); border-color: var(--present); color: #111; }
  .tile.correct { background: var(--correct); border-color: var(--correct); }
  .controls { 
    display: flex; gap: 8px; margin: 10px 0 4px; align-items: center; flex-wrap: wrap;
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
  }
  button, select {
    background: #1b1b1b; color: var(--fg); border: 1px solid #333; border-radius: 6px;
    padding: 8px 10px; cursor: pointer; font-weight: 600;
    min-height: 44px; /* iOS recommended touch target size */
    touch-action: manipulation; /* Prevents zoom on double-tap */
  }
  button.primary { background: var(--accent); color: #081424; border-color: transparent; }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .kbd { display: grid; gap: 6px; margin-top: 8px; }
  .kbd-row { display: grid; gap: 6px; grid-template-columns: repeat(20, 1fr); }
  .key { 
    grid-column: span 2; 
    min-height: 44px; /* Better touch targets */
    touch-action: manipulation; /* Prevents zoom on double-tap */
  }
  .key.wide { grid-column: span 3; }
  .key.state-absent { background: var(--absent); border-color: var(--absent); }
  .key.state-present { background: var(--present); border-color: var(--present); color: #111; }
  .key.state-correct { background: var(--correct); border-color: var(--correct); }
  .msg { min-height: 22px; color: var(--muted); margin: 6px 0 2px; font-weight: 500; }
  a { color: var(--accent); text-decoration: none; }
  .title { font-weight: 800; letter-spacing: .5px; }
  .hint { color: var(--muted); font-size: 12px; }
  .stats { display:flex; gap:12px; align-items:center; flex-wrap:wrap; font-size:13px; color:var(--muted); }
  .pill { background:#1b1b1b; border:1px solid #333; border-radius:999px; padding:4px 8px; color:#ddd; }
  .dialog-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:1000; padding:20px; box-sizing:border-box; }
  .dialog { background:var(--bg); border:2px solid #333; border-radius:12px; padding:24px; max-width:400px; width:90%; text-align:center; max-height:80vh; overflow-y:auto; }
  .dialog h2 { margin:0 0 16px; font-size:28px; }
  .dialog .win { color:var(--correct); }
  .dialog .lose { color:#ff6b6b; }
  .dialog .answer-word { font-size:32px; font-weight:800; margin:16px 0; letter-spacing:2px; }
  .dialog button { margin-top:20px; padding:12px 24px; font-size:16px; min-height:48px; }
  .dialog input { 
    margin:10px 0; padding:8px 12px; border:1px solid #333; border-radius:6px; 
    background:var(--tile-bg); color:var(--fg); font-size:16px; width:200px;
    /* Prevent zoom on iOS when focusing inputs */
    font-size: max(16px, 1em);
  }
  .name-display { color:var(--accent); font-weight:600; }
  .error-shake { animation: shake 0.5s ease-in-out; }
  @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
  
  /* Mobile-specific improvements */
  @media (max-width: 768px) {
    .msg { font-size: 14px; min-height: 30px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; }
    .dialog { font-size: 16px; }
    .dialog .answer-word { font-size: 28px; }
    .key { font-size: 14px; }
    .tile { font-size: clamp(14px, 4vw, 20px); }
    
    /* Force error message visibility on mobile */
    .msg.error-shake {
      background: #ff6b6b !important;
      color: white !important;
      font-size: 16px !important;
      padding: 12px !important;
      border: 3px solid #ffffff !important;
      box-shadow: 0 0 20px rgba(255, 107, 107, 0.8) !important;
      animation: shake 0.5s ease-in-out, flash 2s ease-in-out !important;
    }
    
    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <span class="title" id="appTitle">wxrdle lite</span>
    <span class="hint" id="puzzleMeta"></span>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="controls">
      <label>Length:
        <select id="lengthSelect"></select>
      </label>
      <label>Category:
        <select id="categorySelect"></select>
      </label>
      <button id="newDailyBtn">New daily</button>
      <button id="newRandomBtn">New random</button>
      <button id="shareBtn">Share</button>
      <button id="nameBtn">ðŸ‘¤ Name</button>
      <span class="hint">Type or use keyboard below.</span>
    </div>

    <div class="stats" id="stats"></div>

    <div id="board"></div>
    <div class="msg" id="msg"></div>

    <div class="kbd" id="kbd"></div>
  </div>
</main>

<footer>
  <div class="wrap">
  </div>
</footer>

<script>
(async function(){
  let cfg;
  try {
    cfg = await fetch('config.json').then(r => r.json());
  } catch (e) {
    console.error('Failed to load config.json:', e);
    cfg = { title: 'WillkeWorld Wordle Wonder', defaultWordLength: 5, maxGuesses: 6, mode: 'daily' };
  }
  document.getElementById('appTitle').textContent = cfg.title || 'WillkeWorld Wordle Wonder';

  // State
  let WORD_LEN = cfg.defaultWordLength ?? 5;
  let MAX_GUESSES = cfg.maxGuesses ?? 6;
  let MODE = cfg.mode === 'random' ? 'random' : 'daily';
  let CURRENT_CATEGORY = 'sports'; // Default category
  let CATEGORIES = {};
  let ANSWERS = [];
  let ALLOWED = new Set();
  let PUZZLE_ID = '';
  let ANSWER = '';
  let GUESSES = [];
  let LOCKED = false;

  // UI refs
  const board = document.getElementById('board');
  const msg = document.getElementById('msg');
  const kbd = document.getElementById('kbd');
  const meta = document.getElementById('puzzleMeta');
  const lenSel = document.getElementById('lengthSelect');
  const catSel = document.getElementById('categorySelect');
  const statsEl = document.getElementById('stats');

  // localStorage stats helpers
  const STATS_KEY = 'wxrdle-lite-stats';
  const USER_NAME_KEY = 'wxrdle-lite-username';
  
  function loadStats() {
    try { return JSON.parse(localStorage.getItem(STATS_KEY) || '{}'); } catch { return {}; }
  }
  function saveStats(s) {
    localStorage.setItem(STATS_KEY, JSON.stringify(s));
  }
  function loadUserName() {
    return localStorage.getItem(USER_NAME_KEY) || '';
  }
  function saveUserName(name) {
    localStorage.setItem(USER_NAME_KEY, name.trim());
  }
  function statsBucketKey(mode, len, category) {
    return `${mode}-${len}-${category}`; // daily-5-sports, random-6-history, etc.
  }
  function getBucket(stats, mode, len, category) {
    const key = statsBucketKey(mode, len, category);
    if (!stats[key]) stats[key] = { games:0, wins:0, streak:0, lastWinDate:'', lastPlayedPid:'' };
    return stats[key];
  }
  function todayISO() {
    const t = new Date();
    return new Date(Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate())).toISOString().slice(0,10);
  }
  function updateStatsUI() {
    const s = loadStats();
    const b = getBucket(s, 'daily', WORD_LEN, CURRENT_CATEGORY);
    const r = getBucket(s, 'random', WORD_LEN, CURRENT_CATEGORY);
    const userName = loadUserName();
    const greeting = userName ? `<span class="name-display">${userName}</span>'s Stats: ` : '';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    
    statsEl.innerHTML = `
      ${greeting}
      <span class="pill">${catName} Daily ${WORD_LEN}: G ${b.games} â€¢ W ${b.wins} â€¢ Streak ${b.streak}</span>
      <span class="pill">${catName} Random ${WORD_LEN}: G ${r.games} â€¢ W ${r.wins}</span>
    `;
  }

  // discover available categories and lengths
  CATEGORIES = {
    'sports': { name: 'Sports', description: 'Athletic terms and games' },
    'history': { name: 'US History', description: 'American historical terms' },
    'music': { name: 'Music', description: 'Musical terms and instruments' },
    'art': { name: 'Art', description: 'Artistic terms and techniques' },
    'literature': { name: 'Literature', description: 'Literary terms and authors' },
    'bible': { name: 'Bible', description: 'Biblical terms and names' }
  };

  const availCategories = [];
  const availLengths = new Set();
  
  for (const [catKey, catInfo] of Object.entries(CATEGORIES)) {
    let foundCategory = false;
    for (let l = 3; l <= 10; l++) {
      try {
        const res = await fetch(`words/${catKey}/answers-${l}.txt`, { cache: 'no-store' });
        if (res.ok) {
          foundCategory = true;
          availLengths.add(l);
        }
      } catch (e) {
        // Category/length combo doesn't exist, that's fine
      }
    }
    if (foundCategory) {
      availCategories.push(catKey);
    }
  }

  const avail = Array.from(availLengths).sort((a, b) => a - b);
  
  if (avail.length === 0 || availCategories.length === 0) { 
    msg.textContent = 'No word lists found. Add category folders like /words/sports/answers-5.txt'; 
    console.error('No word files found in /words/ directory');
    return; 
  }

  console.log('Available categories:', availCategories);
  console.log('Available word lengths:', avail);

  // Set up category selector
  catSel.innerHTML = availCategories.map(cat => 
    `<option value="${cat}">${CATEGORIES[cat].name}</option>`
  ).join('');
  CURRENT_CATEGORY = availCategories.includes('sports') ? 'sports' : availCategories[0];
  catSel.value = CURRENT_CATEGORY;

  lenSel.innerHTML = avail.map(l => `<option value="${l}">${l}</option>`).join('');
  lenSel.value = String(avail.includes(WORD_LEN) ? WORD_LEN : avail[0]);

  lenSel.addEventListener('change', async () => { 
    WORD_LEN = Number(lenSel.value); 
    await loadLists(); 
    newPuzzle(MODE); 
    updateStatsUI(); 
  });
  
  catSel.addEventListener('change', async () => { 
    CURRENT_CATEGORY = catSel.value; 
    await loadLists(); 
    newPuzzle(MODE); 
    updateStatsUI(); 
  });

  document.getElementById('newDailyBtn').addEventListener('click', () => { MODE='daily'; newPuzzle('daily'); });
  document.getElementById('newRandomBtn').addEventListener('click', () => { MODE='random'; newPuzzle('random'); });
  document.getElementById('shareBtn').addEventListener('click', shareResult);
  document.getElementById('nameBtn').addEventListener('click', showNameDialog);

  const rows = ['qwertyuiop','asdfghjkl','â†µzxcvbnmâŒ«'];
  function renderKeyboard() {
    kbd.innerHTML = '';
    for (const r of rows) {
      const row = document.createElement('div'); row.className = 'kbd-row';
      for (const ch of r) {
        const b = document.createElement('button'); b.className = 'key'; if (ch==='â†µ'||ch==='âŒ«') b.classList.add('wide');
        b.textContent = ch;
        b.addEventListener('click', () => {
          if (ch==='â†µ') submitGuess();
          else if (ch==='âŒ«') backspace();
          else typeChar(ch);
        });
        row.appendChild(b);
      }
      kbd.appendChild(row);
    }
  }

  function updateKeyStates() {
    const states = {}; const rank = {absent:0,present:1,correct:2};
    for (const g of GUESSES) {
      if (g.length !== ANSWER.length) continue;
      const tiles = scoreGuess(ANSWER,g);
      tiles.forEach((s,i) => {
        const c = g[i];
        if (!(c in states) || rank[s] > rank[states[c]]) states[c] = s;
      });
    }
    for (const btn of kbd.querySelectorAll('.key')) {
      const c = btn.textContent;
      if (!c || c.length!==1 || !/[a-z]/.test(c)) continue;
      btn.classList.remove('state-absent','state-present','state-correct');
      if (states[c]) btn.classList.add('state-'+states[c]);
    }
  }

  function renderBoard() {
    board.style.setProperty('--len', WORD_LEN);
    board.innerHTML = '';
    for (let r = 0; r < MAX_GUESSES; r++) {
      const row = document.createElement('div'); 
      row.className = 'row';
      const guess = GUESSES[r] || '';
      const isDone = r < GUESSES.length - 1 || (r < GUESSES.length && guess.length === WORD_LEN && !LOCKED);
      const tiles = isDone ? scoreGuess(ANSWER, guess) : [];
      
      for (let c = 0; c < WORD_LEN; c++) {
        const t = document.createElement('div'); 
        t.className = 'tile';
        t.textContent = guess[c] ? guess[c].toUpperCase() : '';
        if (isDone && guess.length === WORD_LEN) t.classList.add(tiles[c]); 
        row.appendChild(t);
      }
      board.appendChild(row);
    }
  }

  function seedIndex(seedStr, modulo) {
    let h = 2166136261 >>> 0;
    for (let i=0;i<seedStr.length;i++){ h ^= seedStr.charCodeAt(i); h = Math.imul(h, 16777619) >>> 0; }
    return modulo ? (h % modulo) : 0;
  }

  async function loadLists() {
    try {
      const ans = await fetch(`words/${CURRENT_CATEGORY}/answers-${WORD_LEN}.txt`, { cache:'no-store' }).then(r => r.text());
      const alw = await fetch(`words/${CURRENT_CATEGORY}/allowed-${WORD_LEN}.txt`, { cache:'no-store' }).then(r => r.text()).catch(()=> '');
      const sanitize = (txt) => [...new Set(txt.split(/\r?\n/).map(s => s.trim().toLowerCase()).filter(s => s.length===WORD_LEN && /^[a-z]+$/.test(s)))];
      ANSWERS = sanitize(ans);
      ALLOWED = new Set(sanitize(alw).concat(ANSWERS));
      console.log(`Loaded ${ANSWERS.length} answers and ${ALLOWED.size} allowed words for ${CURRENT_CATEGORY} length ${WORD_LEN}`);
    } catch (e) {
      console.error('Failed to load word lists:', e);
      msg.textContent = `Failed to load word lists for ${CATEGORIES[CURRENT_CATEGORY]?.name} ${WORD_LEN}-letter words.`;
    }
  }

  function getDailyPuzzleId() {
    const today = new Date();
    const iso = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate())).toISOString().slice(0,10);
    return `${iso}-${WORD_LEN}`;
  }

  function puzzleNumber(pid) {
    if (!pid.startsWith('20')) return '?';
    const epoch = new Date(cfg.dailyEpoch || '2024-01-01T00:00:00Z');
    const d = new Date(pid.slice(0,10)+'T00:00:00Z');
    const n = Math.floor((d - epoch) / 86400000);
    return n >= 0 ? n : '?';
  }

  function newPuzzle(mode) {
    GUESSES = []; LOCKED = false;
    let pid, idx;
    if (mode === 'random') {
      const rnd = Math.random().toString(36).slice(2,10);
      pid = `rnd-${rnd}-${WORD_LEN}-${CURRENT_CATEGORY}`;
      idx = seedIndex(`${rnd}:${WORD_LEN}:${CURRENT_CATEGORY}`, ANSWERS.length);
      console.log(`Random mode: rnd=${rnd}, category=${CURRENT_CATEGORY}, idx=${idx}, total=${ANSWERS.length}`);
    } else {
      pid = `${getDailyPuzzleId()}-${CURRENT_CATEGORY}`;
      idx = seedIndex(`${cfg.publicSeed}:${pid}`, ANSWERS.length);
      console.log(`Daily mode: pid=${pid}, seed=${cfg.publicSeed}, category=${CURRENT_CATEGORY}, idx=${idx}, total=${ANSWERS.length}`);
    }
    PUZZLE_ID = pid;
    ANSWER = ANSWERS[idx];
    console.log(`Selected answer: ${ANSWER} (index ${idx})`);
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    meta.textContent = ` â€¢ ${catName} â€¢ ${mode} â€¢ ${WORD_LEN}-letter â€¢ #${puzzleNumber(pid)}`;
    msg.textContent = '';
    renderBoard(); updateKeyStates();
    const s = loadStats(); getBucket(s, mode, WORD_LEN, CURRENT_CATEGORY); s[statsBucketKey(mode,WORD_LEN,CURRENT_CATEGORY)].lastPlayedPid = pid; saveStats(s); updateStatsUI();
  }

  function scoreGuess(answer, guess) {
    const n = answer.length, res = Array(n).fill('absent'), count = {};
    for (let i=0;i<n;i++) count[answer[i]] = (count[answer[i]]||0)+1;
    for (let i=0;i<n;i++) if (guess[i]===answer[i]) { res[i]='correct'; count[guess[i]]--; }
    for (let i=0;i<n;i++) if (res[i]!=='correct' && (count[guess[i]]||0)>0) { res[i]='present'; count[guess[i]]--; }
    return res;
  }

  function typeChar(ch) {
    if (LOCKED) return;
    if (!/^[a-z]$/i.test(ch)) return;
    
    // Always ensure we have a current guess row
    if (GUESSES.length === 0) {
      GUESSES.push('');
    }
    
    // If current row is full, create new row (unless we're at max guesses)
    if (GUESSES[GUESSES.length-1].length === WORD_LEN) {
      if (GUESSES.length >= MAX_GUESSES) return;
      GUESSES.push('');
    }
    
    const i = GUESSES.length-1;
    if (GUESSES[i].length < WORD_LEN) { 
      GUESSES[i] += ch.toLowerCase(); 
      renderBoard(); 
    }
  }
  function backspace() {
    if (LOCKED || GUESSES.length === 0) return;
    const i = GUESSES.length - 1;
    if (GUESSES[i].length === 0) {
      // If current row is empty, remove it if it's not the only row
      if (GUESSES.length > 1) {
        GUESSES.pop();
      }
      return;
    }
    GUESSES[i] = GUESSES[i].slice(0, -1);
    renderBoard();
  }

  function finalizeGame(won) {
    console.log('finalizeGame called with won:', won); // Debug
    LOCKED = true;
    const s = loadStats();
    const b = getBucket(s, MODE, WORD_LEN, CURRENT_CATEGORY);

    // Count games only once per puzzleId (avoid F5 spam)
    const alreadyCounted = b._countedPid === PUZZLE_ID;
    if (!alreadyCounted) {
      b.games += 1;
      b._countedPid = PUZZLE_ID;
    }

    if (won && !b._wonPid?.includes(PUZZLE_ID)) {
      b.wins += 1;
      const today = todayISO();
      // streak only applies to daily mode
      if (MODE === 'daily') {
        if (b.lastWinDate) {
          const prev = new Date(b.lastWinDate+'T00:00:00Z');
          const cur = new Date(today+'T00:00:00Z');
          const diff = Math.round((cur - prev)/86400000);
          b.streak = diff === 1 ? (b.streak+1) : (diff === 0 ? b.streak : 1);
        } else {
          b.streak = 1;
        }
        b.lastWinDate = today;
      }
      b._wonPid = (b._wonPid || []).concat(PUZZLE_ID);
    } else if (!won && MODE === 'daily') {
      // a loss breaks streak for daily if played today
      const today = todayISO();
      const pidDay = PUZZLE_ID.slice(0,10);
      if (pidDay === today) b.streak = 0;
    }

    saveStats(s);
    updateStatsUI();
    
    console.log('About to call showGameDialog with won:', won); // Debug
    // Show win/lose dialog
    showGameDialog(won);
  }

  function showGameDialog(won) {
    console.log('showGameDialog called with won:', won); // Debug
    
    // Remove any existing dialogs first
    const existingOverlay = document.querySelector('.dialog-overlay');
    if (existingOverlay) {
      console.log('Removing existing dialog'); // Debug
      existingOverlay.remove();
    }
    
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    
    const dialog = document.createElement('div');
    dialog.className = 'dialog';
    
    const userName = loadUserName();
    const personalGreeting = userName ? ` ${userName}` : '';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    
    console.log('Creating dialog content for', won ? 'win' : 'lose'); // Debug
    
    if (won) {
      dialog.innerHTML = `
        <h2 class="win">ðŸŽ‰ Congratulations${personalGreeting}!</h2>
        <p>You solved today's ${catName} Wordle!</p>
        <div class="answer-word">${ANSWER.toUpperCase()}</div>
        <p>Solved in ${GUESSES.length} guess${GUESSES.length === 1 ? '' : 'es'}!</p>
        <button id="continueBtn" style="font-size:18px; padding:12px 24px;">Continue</button>
      `;
    } else {
      dialog.innerHTML = `
        <h2 class="lose">ðŸ˜” Game Over${personalGreeting}</h2>
        <p>Better luck next time!</p>
        <div class="answer-word">${ANSWER.toUpperCase()}</div>
        <p>The word was <strong>${ANSWER.toUpperCase()}</strong></p>
        <button id="continueBtn" style="font-size:18px; padding:12px 24px;">Try Again Tomorrow</button>
      `;
    }
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    console.log('Dialog added to DOM'); // Debug
    
    // Add click handler to the button
    const continueBtn = dialog.querySelector('#continueBtn');
    continueBtn.addEventListener('click', () => {
      console.log('Continue button clicked'); // Debug
      overlay.remove();
    });
    
    // Ensure dialog is visible on mobile
    setTimeout(() => {
      console.log('Scrolling dialog into view'); // Debug
      dialog.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Force focus on the button for mobile accessibility
      continueBtn.focus();
    }, 200);
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        console.log('Overlay clicked, closing dialog'); // Debug
        overlay.remove();
      }
    });
    
    // Close on Escape key
    const closeOnEscape = (e) => {
      if (e.key === 'Escape') {
        console.log('Escape pressed, closing dialog'); // Debug
        overlay.remove();
        document.removeEventListener('keydown', closeOnEscape);
      }
    };
    document.addEventListener('keydown', closeOnEscape);
    
    // Auto-close after 15 seconds if user doesn't interact (mobile fallback)
    const autoClose = setTimeout(() => {
      console.log('Auto-closing dialog after timeout'); // Debug
      if (document.body.contains(overlay)) {
        overlay.remove();
      }
    }, 15000);
    
    // Cancel auto-close if user clicks
    overlay.addEventListener('click', () => {
      clearTimeout(autoClose);
    });
    
    console.log('Dialog setup complete'); // Debug
    
    // Mobile fallback - ALWAYS show alert
    console.log('Mobile detected, setting up alert fallback'); // Debug
    setTimeout(() => {
      console.log('Showing alert for mobile'); // Debug
      const alertMessage = won ? 
        `ðŸŽ‰ You won! The word was ${ANSWER.toUpperCase()}. Solved in ${GUESSES.length} guess${GUESSES.length === 1 ? '' : 'es'}!` :
        `ðŸ˜” Game Over! The word was ${ANSWER.toUpperCase()}.`;
      try {
        alert(alertMessage);
        console.log('Game dialog alert shown successfully');
      } catch(e) {
        console.log('Game dialog alert failed:', e);
      }
    }, 200);
  }

  function showNameDialog() {
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    
    const dialog = document.createElement('div');
    dialog.className = 'dialog';
    
    const currentName = loadUserName();
    
    dialog.innerHTML = `
      <h2>ðŸ‘¤ Enter Your Name</h2>
      <p>Personalize your WillkeWorld Wordle Wonder experience!</p>
      <input type="text" id="nameInput" placeholder="Enter your name" value="${currentName}" maxlength="20">
      <div>
        <button onclick="saveName()">Save Name</button>
        <button onclick="this.closest('.dialog-overlay').remove()" style="margin-left:10px;">Cancel</button>
      </div>
    `;
    
    // Make saveName function available globally for the onclick
    window.saveName = () => {
      const nameInput = document.getElementById('nameInput');
      const name = nameInput.value.trim();
      if (name) {
        saveUserName(name);
        updateStatsUI();
        overlay.remove();
        showErrorMessage(`Welcome, ${name}! ðŸ‘‹`);
      } else {
        nameInput.style.borderColor = '#ff6b6b';
        nameInput.focus();
      }
    };
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Focus the input
    setTimeout(() => {
      const input = document.getElementById('nameInput');
      input.focus();
      input.select();
    }, 100);
    
    // Handle Enter key in input
    dialog.querySelector('#nameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        window.saveName();
      } else if (e.key === 'Escape') {
        overlay.remove();
      }
    });
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
  }

  function showErrorMessage(message) {
    console.log('Showing error message:', message); // Debug log
    msg.textContent = message;
    msg.classList.add('error-shake');
    msg.style.color = '#ff6b6b !important'; // Make error more visible
    msg.style.backgroundColor = 'rgba(255, 107, 107, 0.9) !important'; // Stronger background
    msg.style.padding = '12px !important';
    msg.style.borderRadius = '8px !important';
    msg.style.fontWeight = 'bold !important';
    msg.style.fontSize = '16px !important'; // Larger text for mobile
    msg.style.border = '2px solid #ff6b6b !important'; // Border for visibility
    msg.style.zIndex = '999 !important'; // Ensure it's on top
    msg.style.position = 'relative !important';
    
    // Force visibility on mobile with multiple methods
    msg.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    // Mobile-specific: Force repaint
    msg.style.transform = 'translateZ(0)';
    msg.offsetHeight; // Force reflow
    
    // Mobile fallback - ALWAYS show alert for critical messages
    console.log('Mobile detected, showing alert as fallback'); // Debug
    setTimeout(() => {
      try {
        alert(message);
        console.log('Alert shown successfully');
      } catch(e) {
        console.log('Alert failed:', e);
        // Final fallback - try to make message area flash
        msg.style.backgroundColor = '#ff0000 !important';
        setTimeout(() => {
          msg.style.backgroundColor = 'rgba(255, 107, 107, 0.9) !important';
        }, 200);
      }
    }, 50);
    
    setTimeout(() => {
      msg.classList.remove('error-shake');
      msg.style.cssText = ''; // Reset all styles at once
    }, 4000); // Longer duration for mobile
  }

  function submitGuess() {
    console.log('submitGuess called, LOCKED:', LOCKED, 'GUESSES.length:', GUESSES.length); // Debug
    if (LOCKED || GUESSES.length === 0) return;
    const i = GUESSES.length - 1;
    const g = GUESSES[i];
    
    console.log('Submitting guess:', g, 'length:', g.length, 'required:', WORD_LEN); // Debug
    
    // Must have exactly WORD_LEN letters
    if (g.length !== WORD_LEN) { 
      console.log('Not enough letters'); // Debug
      showErrorMessage('Not enough letters.');
      return; 
    }
    
    console.log('Checking if allowed:', g, 'in set:', ALLOWED.has(g)); // Debug
    
    // Must be a valid dictionary word
    if (!ALLOWED.has(g)) { 
      console.log('Invalid word detected:', g); // Debug
      showErrorMessage(`"${g.toUpperCase()}" is not a valid word! Clearing...`);
      // Clear the invalid word immediately and re-render
      GUESSES[i] = '';
      console.log('Cleared guess, re-rendering'); // Debug
      renderBoard();
      // Force a brief pause to show the error message
      setTimeout(() => {
        console.log('Second render after clear'); // Debug
        renderBoard(); // Re-render to ensure UI is updated
      }, 200);
      return; 
    }

    console.log('Valid word, processing guess'); // Debug
    // Score the guess and update display
    const tiles = scoreGuess(ANSWER, g);
    renderBoard(); 
    updateKeyStates();
    const win = tiles.every(t => t === 'correct');

    console.log(`Guess ${GUESSES.length}: "${g}", Win: ${win}, Max: ${MAX_GUESSES}`);

    if (win) { 
      msg.textContent = 'You win! ðŸŽ‰'; 
      console.log('Player won, calling finalizeGame(true)'); // Debug
      finalizeGame(true); 
      return; 
    }
    
    // Check if this was the last allowed guess
    if (GUESSES.length >= MAX_GUESSES) {
      console.log(`Game over! Final guess count: ${GUESSES.length}, Max: ${MAX_GUESSES}, Answer: ${ANSWER}`);
      msg.textContent = `Out of guesses. The word was ${ANSWER.toUpperCase()}.`;
      finalizeGame(false);
      return;
    }
    
    // Clear message for next guess
    msg.textContent = '';
  }

  async function shareResult() {
    if (GUESSES.length === 0) {
      msg.textContent = 'Play a game first before sharing!';
      return;
    }
    
    const rows = GUESSES.slice(0, Math.min(GUESSES.length, MAX_GUESSES));
    const squares = rows.map(g => scoreGuess(ANSWER,g).map(x => x==='correct'?'ðŸŸ©': x==='present'?'ðŸŸ¨':'â¬›').join('')).join('\n');
    const won = rows.length>0 && scoreGuess(ANSWER, rows[rows.length-1]).every(x=>x==='correct');
    const attempts = won ? rows.length : 'X';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    const text = [
      `${catName} Wordle ${puzzleNumber(PUZZLE_ID)} ${attempts}/${MAX_GUESSES}`,
      '',
      squares
    ].join('\n');
    
    console.log('Sharing text:', text);
    
    try {
      // Try modern clipboard API first
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text); 
        msg.textContent = 'Copied result to clipboard âœ… Ready to paste!'; 
        return;
      }
      
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      if (document.execCommand('copy')) {
        msg.textContent = 'Copied result to clipboard âœ… Ready to paste!';
      } else {
        throw new Error('execCommand failed');
      }
      document.body.removeChild(textArea);
      
    } catch (err) {
      console.error('Share failed:', err);
      msg.textContent = `Share failed. Try manually copying: ${text}`;
    }
  }

  // physical keyboard
  window.addEventListener('keydown', (e) => {
    // Don't handle keyboard events when a dialog is open or when typing in an input field
    if (document.querySelector('.dialog-overlay') || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return;
    }
    
    if (e.key==='Enter') {
      e.preventDefault(); // Prevent form submission on mobile
      submitGuess();
    }
    else if (e.key==='Backspace') {
      e.preventDefault(); // Prevent navigation on mobile
      backspace();
    }
    else if (/^[a-z]$/i.test(e.key)) typeChar(e.key);
  });

  // Mobile-specific touch event handling
  let touchStartY = 0;
  let touchEndY = 0;
  
  document.addEventListener('touchstart', (e) => {
    touchStartY = e.changedTouches[0].screenY;
  });
  
  document.addEventListener('touchend', (e) => {
    touchEndY = e.changedTouches[0].screenY;
    // Prevent pull-to-refresh on mobile
    if (touchStartY < touchEndY) {
      e.preventDefault();
    }
  });

  // boot
  renderKeyboard();
  await loadLists();
  newPuzzle(MODE);
  updateStatsUI();
  
  // Show name dialog on first visit if no name is set
  if (!loadUserName()) {
    setTimeout(() => {
      showNameDialog();
    }, 500); // Reduced delay from 1000ms to 500ms
  }
})();
</script>
</body>
</html>
