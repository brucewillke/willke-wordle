<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no"
/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Wordle Wonder">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#111111">
<link rel="apple-touch-icon" sizes="180x180" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiBmaWxsPSIjMTExIiByeD0iMzAiLz4KPHN2ZyB4PSI0MCIgeT0iNDAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj4KPHN2ZyB4PSIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCI+CjxyZWN0IHg9IjUiIHk9IjUiIHdpZHRoPSIyNSIgaGVpZ2h0PSIyNSIgZmlsbD0iIzUzOGQ0ZSIgcng9IjMiLz4KPHJlY3QgeD0iMzUiIHk9IjUiIHdpZHRoPSIyNSIgaGVpZ2h0PSIyNSIgZmlsbD0iI2I1OWYzYiIgcng9IjMiLz4KPHJlY3QgeD0iNjUiIHk9IjUiIHdpZHRoPSIyNSIgaGVpZ2h0PSIyNSIgZmlsbD0iIzNhM2EzYyIgcng9IjMiLz4KPHRleHQgeD0iNTAiIHk9Ijc1IiBmb250LWZhbWlseT0ic3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjE2IiBmb250LXdlaWdodD0iYm9sZCIgZmlsbD0iI2YyZjJmMiIgdGV4dC1hbmNob3I9Im1pZGRsZSI+V29yZGxlPC90ZXh0Pgo8L3N2Zz4KPC9zdmc+Cjwvc3ZnPgo=">
<title>WillkeWorld Wordle Wonder</title>
<style>
  :root {
    --bg: #111;
    --fg: #f2f2f2;
    --muted: #aaa;
    --tile-bg: #222;
    --absent: #3a3a3c;
    --present: #b59f3b;
    --correct: #538d4e;
    --accent: #6ca0ff;
  }
  html, body { height: 100%; }
  body {
    margin: 0; background: var(--bg); color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
    display: flex; 
    flex-direction: column;
    /* iOS and mobile optimizations */
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
    text-size-adjust: 100%;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    overscroll-behavior: none; /* Prevent overscroll bounce */
    min-height: 100vh;
    height: auto;
  }
  header, footer { padding: 8px 14px; border-bottom: 1px solid #222; flex-shrink: 0; }
  footer { border-top: 1px solid #222; border-bottom: none; color: var(--muted); font-size: 12px; }
  
  main {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    display: flex;
    flex-direction: column;
  }
  
  .wrap { max-width: 560px; margin: 0 auto; padding: 8px 12px; flex: 1; display: flex; flex-direction: column; }
  .game-container { flex: 1; display: flex; flex-direction: column; justify-content: center; min-height: 0; }
  #board { flex: 0 1 auto; }
  .msg { flex-shrink: 0; }
  .row { display: grid; gap: 3px; grid-template-columns: repeat(var(--len), 1fr); margin: 2px 0; }
  .tile {
    aspect-ratio: 1 / 1; background: var(--tile-bg); border: 2px solid #333;
    display: grid; place-items: center; font-weight: 700; font-size: clamp(14px, 3vw, 20px);
    text-transform: uppercase; border-radius: 6px;
    touch-action: manipulation; /* Prevent zoom on touch */
    user-select: none; /* Prevent text selection */
    -webkit-tap-highlight-color: transparent; /* Remove iOS tap highlight */
  }
  .tile.absent { background: var(--absent); border-color: var(--absent); }
  .tile.present { background: var(--present); border-color: var(--present); color: #111; }
  .tile.correct { background: var(--correct); border-color: var(--correct); }
  .controls { 
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin: 10px 0 4px;
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
  }
  .controls-row {
    display: flex;
    gap: 6px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: space-between;
  }
  .controls-compact {
    display: flex;
    gap: 4px;
    align-items: center;
    font-size: 12px;
  }
  .controls-compact select {
    padding: 4px 6px;
    font-size: 12px;
    min-height: 32px;
  }
  .controls-compact button {
    padding: 4px 8px;
    font-size: 11px;
    min-height: 32px;
    white-space: nowrap;
  }
  .game-actions button {
    flex: 1;
    min-width: 80px;
  }
  .settings-toggle {
    background: var(--accent);
    color: #081424;
    border: none;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    margin: 4px 0;
    display: block;
    width: fit-content;
    margin: 4px auto;
  }
  
  /* Bottom sheet overlay styles */
  .settings-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }
  
  .settings-overlay.open {
    opacity: 1;
    visibility: visible;
  }
  
  .settings-sheet {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--bg);
    border-top: 2px solid #333;
    border-radius: 20px 20px 0 0;
    padding: 20px;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.3);
    z-index: 1001;
  }
  
  .settings-sheet.open {
    transform: translateY(0);
  }
  
  .settings-sheet-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 24px;
    padding-bottom: 16px;
    border-bottom: 1px solid #333;
  }
  
  .settings-sheet-title {
    font-size: 20px;
    font-weight: 700;
    color: var(--fg);
  }
  
  .settings-close-btn {
    background: transparent;
    border: none;
    color: var(--muted);
    font-size: 24px;
    cursor: pointer;
    padding: 4px;
    line-height: 1;
    border-radius: 4px;
  }
  
  .settings-close-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }
  
  .settings-sheet-content {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  
  .settings-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .settings-label {
    font-size: 16px;
    font-weight: 600;
    color: var(--fg);
  }
  
  .settings-description {
    font-size: 14px;
    color: var(--muted);
    margin-bottom: 8px;
  }
  
  /* Hide the old inline settings panel on mobile */
  .settings-panel {
    overflow: hidden;
    transition: max-height 0.3s ease-out;
    max-height: 0;
  }
  
  .settings-panel.open {
    max-height: 200px;
  }
  
  /* Hide bottom sheet on desktop */
  .settings-overlay {
    display: none;
  }
  
  /* Show bottom sheet on mobile */
  @media (max-width: 768px) {
    .settings-overlay {
      display: block;
    }
    
    .settings-panel {
      display: none !important;
    }
  }
  button, select {
    background: #1b1b1b; color: var(--fg); border: 1px solid #333; border-radius: 8px;
    padding: 12px 16px; cursor: pointer; font-weight: 600;
    min-height: 48px; /* iOS recommended touch target size */
    touch-action: manipulation; /* Prevents zoom on double-tap */
    -webkit-tap-highlight-color: transparent; /* Remove iOS tap highlight */
    -webkit-appearance: none; /* Remove iOS default styling */
    appearance: none; /* Standard property for compatibility */
    user-select: none; /* Prevent text selection */
    font-size: 16px; /* Prevent iOS zoom on input focus */
    transition: all 0.1s ease; /* Fast response for all buttons */
  }
  
  button:active {
    transform: translateY(1px);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
  }
  button.primary { background: var(--accent); color: #081424; border-color: transparent; }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .kbd { display: grid; gap: 4px; margin-top: 6px; flex-shrink: 0; }
  .kbd-row { display: flex; gap: 4px; justify-content: center; align-items: center; }
  .key { 
    min-width: 43px; /* Consistent width for letter keys */
    min-height: 42px; /* Smaller but still touchable */
    touch-action: manipulation; /* Prevents zoom on double-tap */
    -webkit-tap-highlight-color: transparent; /* Remove iOS tap highlight */
    font-size: 14px; /* Smaller font for compact layout */
    border-radius: 6px; 
    user-select: none; /* Prevent text selection */
    cursor: pointer;
    transition: all 0.1s ease; /* Fast visual feedback */
    position: relative;
    overflow: hidden;
    font-weight: 700;
  }
  .key.wide { 
    min-width: 65px; /* Wider for ENTER and DELETE */
    font-size: 12px;
    font-weight: 700;
  }
  .key:active {
    transform: scale(0.95);
    background-color: #333;
  }
  .key:hover:not(:active) {
    background-color: #2a2a2a;
  }
  .key::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.3s ease, height 0.3s ease;
    pointer-events: none;
  }
  .key.ripple::after {
    width: 100px;
    height: 100px;
  }
  .key.wide { grid-column: span 3; }
  .key.state-absent { background: var(--absent); border-color: var(--absent); }
  .key.state-present { background: var(--present); border-color: var(--present); color: #111; }
  .key.state-correct { background: var(--correct); border-color: var(--correct); }
  .msg { min-height: 22px; color: var(--muted); margin: 6px 0 2px; font-weight: 500; }
  a { color: var(--accent); text-decoration: none; }
  .title { font-weight: 800; letter-spacing: .5px; }
  .hint { color: var(--muted); font-size: 12px; }
  .stats { display:flex; gap:12px; align-items:center; flex-wrap:wrap; font-size:13px; color:var(--muted); }
  .pill { background:#1b1b1b; border:1px solid #333; border-radius:999px; padding:4px 8px; color:#ddd; }
  .dialog-overlay { position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:1000; padding:20px; box-sizing:border-box; }
  .dialog { background:var(--bg); border:2px solid #333; border-radius:12px; padding:24px; max-width:400px; width:90%; text-align:center; max-height:80vh; overflow-y:auto; }
  .dialog h2 { margin:0 0 16px; font-size:28px; }
  .dialog .win { color:var(--correct); }
  .dialog .lose { color:#ff6b6b; }
  .dialog .answer-word { font-size:32px; font-weight:800; margin:16px 0; letter-spacing:2px; }
  .dialog button { margin-top:20px; padding:12px 24px; font-size:16px; min-height:48px; }
  .dialog input { 
    margin:10px 0; padding:12px 16px; border:1px solid #333; border-radius:8px; 
    background:var(--tile-bg); color:var(--fg); width:240px;
    /* Prevent zoom on iOS when focusing inputs */
    font-size: 16px; /* Must be 16px+ to prevent iOS zoom */
    -webkit-tap-highlight-color: transparent; /* Remove iOS tap highlight */
    -webkit-appearance: none; /* Remove iOS default styling */
    appearance: none; /* Standard property for compatibility */
    touch-action: manipulation; /* Prevent zoom on touch */
  }
  .name-display { color:var(--accent); font-weight:600; }
  .error-shake { animation: shake 0.5s ease-in-out; }
  @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
  
  /* Mobile-specific improvements */
  @media (max-width: 768px) {
    /* Ensure game board and keyboard are both visible */
    .game-container {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      max-height: calc(100vh - 240px); /* Reserve space for controls and keyboard */
    }
    
    #board {
      flex: 0 1 auto;
      max-height: calc(50vh - 120px); /* Limit board height */
      overflow: visible;
    }
    
    .wrap {
      padding: 4px 8px;
      gap: 6px;
      height: auto;
      min-height: calc(100vh - 80px); /* Account for header/footer */
    }
    
    /* Compact board */
    .row {
      gap: 2px;
      margin: 1px 0;
    }
    
    /* Very compact tiles for mobile */
    .tile { 
      font-size: clamp(12px, 3.5vw, 16px);
      border-radius: 4px;
      border-width: 1px;
      min-height: auto; /* Let aspect ratio control height */
    }
    
    /* Compact keyboard */
    .kbd {
      gap: 3px;
      margin-top: 4px;
      margin-bottom: 8px;
    }
    .kbd-row {
      gap: 2px;
    }
    .key { 
      font-size: 12px;
      min-height: 36px; /* Smaller for mobile */
      min-width: 32px;
      border-radius: 4px;
      font-weight: 500;
      transition: all 0.08s ease; /* Very fast response */
    }
    .key:active {
      transform: scale(0.92);
      background-color: #444 !important;
      transition: all 0.05s ease;
    }
    .key.wide {
      min-width: 50px;
      font-size: 10px;
      font-weight: 700;
    }
    
    /* Mobile bottom sheet settings */
    .settings-overlay {
      display: block;
    }
    
    .settings-panel {
      display: none !important; /* Hide inline panel on mobile */
    }
    
    .settings-sheet select {
      padding: 12px 16px;
      font-size: 16px; /* Prevent iOS zoom */
      min-height: 48px;
      border-radius: 8px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--tile-bg);
      color: var(--fg);
      border: 2px solid #333;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23f2f2f2' stroke-width='2'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 16px center;
      background-size: 16px;
      padding-right: 48px;
      width: 100%;
      box-sizing: border-box;
    }
    
    .settings-sheet select:focus {
      border-color: var(--accent);
      outline: none;
    }
    
    .game-actions button {
      min-width: 50px;
      font-size: 11px;
      padding: 6px 8px;
      flex: 1;
      max-width: 70px;
    }
    
    .settings-toggle {
      font-size: 12px;
      padding: 6px 12px;
      margin: 4px auto;
      min-height: 36px;
      border-radius: 6px;
    }
    
    .controls-compact select {
      padding: 6px 8px;
      font-size: 14px;
      min-height: 36px;
      border-radius: 6px;
    }
    
    .controls-compact button {
      padding: 6px 10px;
      font-size: 12px;
      min-height: 36px;
      border-radius: 6px;
    }
    
    .controls-compact {
      gap: 8px;
      font-size: 12px;
      padding: 6px 0;
    }
    
    .controls-compact label {
      gap: 4px;
      min-width: 100px;
    }
    
    /* Compact messages and stats */
    .hint {
      font-size: 12px;
      margin: 4px 0;
      padding: 4px;
      border-radius: 6px;
    }
    
    .msg { 
      font-size: 14px; 
      min-height: 28px; 
      padding: 8px; 
      margin: 4px 0;
      border-radius: 6px;
    }
    
    .stats {
      font-size: 12px;
      gap: 6px;
      margin: 4px 0;
    }
    .pill {
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
    }
    
    /* Compact dialogs */
    .dialog { 
      font-size: 14px; 
      padding: 20px 16px;
      margin: 10px;
      border-radius: 12px;
    }
    .dialog .answer-word { 
      font-size: 24px; 
      margin: 12px 0;
      letter-spacing: 2px;
    }
    .dialog button {
      min-height: 42px;
      font-size: 16px;
      padding: 12px 20px;
      border-radius: 8px;
      margin-top: 16px;
    }
    
    /* Error styling adjustments */
    .msg.error-shake {
      font-size: 14px !important;
      padding: 10px !important;
      border-radius: 8px !important;
      margin: 6px 0 !important;
    }
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <span class="title" id="appTitle">wxrdle lite</span>
    <span class="hint" id="puzzleMeta"></span>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="controls">
      <div class="controls-row">
        <div class="game-actions">
          <button id="newDailyBtn" class="primary">üìÖ Daily</button>
          <button id="newRandomBtn">üé≤ Random</button>
          <button id="shareBtn">üìã Share</button>
          <button id="nameBtn">üë§</button>
        </div>
      </div>
      
      <button class="settings-toggle" id="settingsToggle">‚öôÔ∏è Settings</button>
      
      <!-- Keep old panel for desktop, hidden on mobile -->
      <div class="settings-panel" id="settingsPanel">
        <div class="controls-compact">
          <label>Length: <select id="lengthSelect"></select></label>
          <label>Category: <select id="categorySelect"></select></label>
        </div>
      </div>
      
      <div class="hint">Type letters, then press Enter ‚Üµ</div>
    </div>

    <!-- Bottom sheet overlay for mobile settings -->
    <div class="settings-overlay" id="settingsOverlay">
      <div class="settings-sheet" id="settingsSheet">
        <div class="settings-sheet-header">
          <div class="settings-sheet-title">‚öôÔ∏è Game Settings</div>
          <button class="settings-close-btn" id="settingsCloseBtn">√ó</button>
        </div>
        <div class="settings-sheet-content">
          <div class="settings-group">
            <div class="settings-label">Word Length</div>
            <div class="settings-description">Choose how many letters each word contains</div>
            <select id="lengthSelectMobile"></select>
          </div>
          <div class="settings-group">
            <div class="settings-label">Category</div>
            <div class="settings-description">Select the theme for your puzzle words</div>
            <select id="categorySelectMobile"></select>
          </div>
        </div>
      </div>
    </div>

    <div class="stats" id="stats"></div>

    <div class="game-container">
      <div id="board"></div>
      <div class="msg" id="msg"></div>
    </div>

    <div class="kbd" id="kbd"></div>
  </div>
</main>

<footer>
  <div class="wrap">
  </div>
</footer>

<script>
(async function(){
  let cfg;
  try {
    cfg = await fetch('config.json').then(r => r.json());
  } catch (e) {
    console.error('Failed to load config.json:', e);
    cfg = { title: 'WillkeWorld Wordle Wonder', defaultWordLength: 5, maxGuesses: 6, mode: 'daily' };
  }
  document.getElementById('appTitle').textContent = cfg.title || 'WillkeWorld Wordle Wonder';

  // State
  let WORD_LEN = cfg.defaultWordLength ?? 5;
  let MAX_GUESSES = cfg.maxGuesses ?? 6;
  let MODE = cfg.mode === 'random' ? 'random' : 'daily';
  let CURRENT_CATEGORY = 'sports'; // Default category
  let CATEGORIES = {};
  let ANSWERS = [];
  let ALLOWED = new Set();
  let PUZZLE_ID = '';
  let ANSWER = '';
  let GUESSES = [];
  let LOCKED = false;

  // UI refs
  const board = document.getElementById('board');
  const msg = document.getElementById('msg');
  const kbd = document.getElementById('kbd');
  const meta = document.getElementById('puzzleMeta');
  const lenSel = document.getElementById('lengthSelect');
  const catSel = document.getElementById('categorySelect');
  const statsEl = document.getElementById('stats');

  // localStorage stats helpers
  const STATS_KEY = 'wxrdle-lite-stats';
  const USER_NAME_KEY = 'wxrdle-lite-username';
  
  function loadStats() {
    try { return JSON.parse(localStorage.getItem(STATS_KEY) || '{}'); } catch { return {}; }
  }
  function saveStats(s) {
    localStorage.setItem(STATS_KEY, JSON.stringify(s));
  }
  function loadUserName() {
    return localStorage.getItem(USER_NAME_KEY) || '';
  }
  function saveUserName(name) {
    localStorage.setItem(USER_NAME_KEY, name.trim());
  }
  function statsBucketKey(mode, len, category) {
    return `${mode}-${len}-${category}`; // daily-5-sports, random-6-history, etc.
  }
  function getBucket(stats, mode, len, category) {
    const key = statsBucketKey(mode, len, category);
    if (!stats[key]) stats[key] = { games:0, wins:0, streak:0, lastWinDate:'', lastPlayedPid:'' };
    return stats[key];
  }
  function todayISO() {
    const t = new Date();
    return new Date(Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate())).toISOString().slice(0,10);
  }
  function updateStatsUI() {
    const s = loadStats();
    const b = getBucket(s, 'daily', WORD_LEN, CURRENT_CATEGORY);
    const r = getBucket(s, 'random', WORD_LEN, CURRENT_CATEGORY);
    const userName = loadUserName();
    const greeting = userName ? `<span class="name-display">${userName}</span>'s Stats: ` : '';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    
    statsEl.innerHTML = `
      ${greeting}
      <span class="pill">${catName} Daily ${WORD_LEN}: G ${b.games} ‚Ä¢ W ${b.wins} ‚Ä¢ Streak ${b.streak}</span>
      <span class="pill">${catName} Random ${WORD_LEN}: G ${r.games} ‚Ä¢ W ${r.wins}</span>
    `;
  }

  // discover available categories and lengths
  CATEGORIES = {
    'sports': { name: 'Sports', description: 'Athletic terms and games' },
    'history': { name: 'US History', description: 'American historical terms' },
    'music': { name: 'Music', description: 'Musical terms and instruments' },
    'art': { name: 'Art', description: 'Artistic terms and techniques' },
    'literature': { name: 'Literature', description: 'Literary terms and authors' },
    'bible': { name: 'Bible', description: 'Biblical terms and names' }
  };

  const availCategories = [];
  const availLengths = new Set();
  
  console.log('Discovering available categories and word lengths...');
  
  for (const [catKey, catInfo] of Object.entries(CATEGORIES)) {
    let foundCategory = false;
    for (let l = 3; l <= 10; l++) {
      try {
        console.log(`Checking: words/${catKey}/answers-${l}.txt`);
        const res = await fetch(`words/${catKey}/answers-${l}.txt`, { 
          cache: 'no-store',
          mode: 'cors',
          method: 'HEAD' // Just check if file exists, don't download content
        });
        if (res.ok) {
          console.log(`‚úì Found ${catKey} length ${l}`);
          foundCategory = true;
          availLengths.add(l);
        } else {
          console.log(`‚úó ${catKey} length ${l}: HTTP ${res.status}`);
        }
      } catch (e) {
        console.log(`‚úó ${catKey} length ${l}: ${e.message}`);
        // Category/length combo doesn't exist or server error - that's fine, continue
      }
    }
    if (foundCategory) {
      availCategories.push(catKey);
      console.log(`‚úì Category ${catKey} (${catInfo.name}) is available`);
    } else {
      console.log(`‚úó Category ${catKey} (${catInfo.name}) has no accessible word files`);
    }
  }

  const avail = Array.from(availLengths).sort((a, b) => a - b);
  
  console.log('Discovery complete:');
  console.log('Available categories:', availCategories);
  console.log('Available word lengths:', avail);
  
  if (avail.length === 0 || availCategories.length === 0) { 
    const errorMsg = `‚ö†Ô∏è Word files not accessible!
    
This could be due to:
‚Ä¢ Server blocking .txt file access
‚Ä¢ CORS restrictions on your web server
‚Ä¢ File permission issues
‚Ä¢ Network connectivity problems

Categories found: ${availCategories.length}
Word lengths found: ${avail.length}

Using emergency fallback mode...`;

    console.error('No word files accessible, using fallback mode');
    showErrorMessage(errorMsg);
    
    // Emergency fallback - provide basic functionality
    availCategories.push('fallback');
    CATEGORIES['fallback'] = { name: 'Emergency Mode', description: 'Basic word set' };
    avail.push(5, 6, 7);
    
    console.log('Emergency fallback activated');
  }

  // Set up category selector
  catSel.innerHTML = availCategories.map(cat => 
    `<option value="${cat}">${CATEGORIES[cat].name}</option>`
  ).join('');
  CURRENT_CATEGORY = availCategories.includes('sports') ? 'sports' : availCategories[0];
  catSel.value = CURRENT_CATEGORY;

  lenSel.innerHTML = avail.map(l => `<option value="${l}">${l}</option>`).join('');
  lenSel.value = String(avail.includes(WORD_LEN) ? WORD_LEN : avail[0]);

  // Mobile selectors (copy options to mobile selectors)
  const lenSelMobile = document.getElementById('lengthSelectMobile');
  const catSelMobile = document.getElementById('categorySelectMobile');
  
  lenSelMobile.innerHTML = lenSel.innerHTML;
  lenSelMobile.value = lenSel.value;
  
  catSelMobile.innerHTML = catSel.innerHTML;
  catSelMobile.value = catSel.value;

  // Sync desktop and mobile selectors
  function syncSelectors() {
    lenSelMobile.value = lenSel.value;
    catSelMobile.value = catSel.value;
  }

  lenSel.addEventListener('change', async () => { 
    WORD_LEN = Number(lenSel.value); 
    await loadLists(); 
    newPuzzle(MODE); 
    updateStatsUI(); 
    syncSelectors();
  });
  
  catSel.addEventListener('change', async () => { 
    CURRENT_CATEGORY = catSel.value; 
    await loadLists(); 
    newPuzzle(MODE); 
    updateStatsUI(); 
    syncSelectors();
  });

  // Mobile selector handlers
  lenSelMobile.addEventListener('change', async () => { 
    WORD_LEN = Number(lenSelMobile.value); 
    lenSel.value = lenSelMobile.value; // Sync back to desktop
    await loadLists(); 
    newPuzzle(MODE); 
    updateStatsUI(); 
  });
  
  catSelMobile.addEventListener('change', async () => { 
    CURRENT_CATEGORY = catSelMobile.value; 
    catSel.value = catSelMobile.value; // Sync back to desktop
    await loadLists(); 
    newPuzzle(MODE); 
    updateStatsUI(); 
  });

  document.getElementById('newDailyBtn').addEventListener('click', () => { MODE='daily'; newPuzzle('daily'); });
  document.getElementById('newRandomBtn').addEventListener('click', () => { MODE='random'; newPuzzle('random'); });
  document.getElementById('shareBtn').addEventListener('click', shareResult);
  document.getElementById('nameBtn').addEventListener('click', showNameDialog);
  
  // Enhanced Settings toggle functionality with bottom sheet support
  function isMobile() {
    return window.innerWidth <= 768;
  }

  function openSettingsBottomSheet() {
    const overlay = document.getElementById('settingsOverlay');
    const sheet = document.getElementById('settingsSheet');
    
    overlay.classList.add('open');
    
    // Small delay to ensure overlay is visible before animating sheet
    setTimeout(() => {
      sheet.classList.add('open');
    }, 50);
    
    // Prevent body scroll when sheet is open
    document.body.style.overflow = 'hidden';
  }

  function closeSettingsBottomSheet() {
    const overlay = document.getElementById('settingsOverlay');
    const sheet = document.getElementById('settingsSheet');
    
    sheet.classList.remove('open');
    
    setTimeout(() => {
      overlay.classList.remove('open');
      document.body.style.overflow = ''; // Re-enable body scroll
    }, 300); // Wait for animation to complete
  }

  document.getElementById('settingsToggle').addEventListener('click', () => {
    if (isMobile()) {
      openSettingsBottomSheet();
    } else {
      // Desktop behavior - use collapsible panel
      const panel = document.getElementById('settingsPanel');
      const toggle = document.getElementById('settingsToggle');
      
      if (panel.classList.contains('open')) {
        panel.classList.remove('open');
        toggle.textContent = '‚öôÔ∏è Settings';
      } else {
        panel.classList.add('open');
        toggle.textContent = '‚öôÔ∏è Hide Settings';
      }
    }
  });

  // Bottom sheet close handlers
  document.getElementById('settingsCloseBtn').addEventListener('click', closeSettingsBottomSheet);
  
  // Close when clicking overlay background
  document.getElementById('settingsOverlay').addEventListener('click', (e) => {
    if (e.target.id === 'settingsOverlay') {
      closeSettingsBottomSheet();
    }
  });

  // Close on escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      const overlay = document.getElementById('settingsOverlay');
      if (overlay.classList.contains('open')) {
        closeSettingsBottomSheet();
      }
    }
  });

  // Handle window resize to switch between mobile/desktop behavior
  window.addEventListener('resize', () => {
    const overlay = document.getElementById('settingsOverlay');
    if (!isMobile() && overlay.classList.contains('open')) {
      closeSettingsBottomSheet();
    }
  });

  const rows = ['qwertyuiop','asdfghjkl','‚Üµzxcvbnm‚å´'];
  
  function addRippleEffect(button) {
    button.classList.add('ripple');
    setTimeout(() => {
      button.classList.remove('ripple');
    }, 300);
  }

  function renderKeyboard() {
    kbd.innerHTML = '';
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      const r = rows[rowIndex];
      const row = document.createElement('div'); 
      row.className = 'kbd-row';
      
      // Special handling for bottom row to get proper Wordle layout
      if (rowIndex === 2) {
        // Bottom row: ENTER + letters + DELETE
        for (const ch of r) {
          const b = document.createElement('button'); 
          b.className = 'key';
          
          if (ch === '‚Üµ') {
            b.classList.add('wide');
            b.textContent = 'ENTER';
            b.style.marginRight = '6px'; // Add space after ENTER
          } else if (ch === '‚å´') {
            b.classList.add('wide');
            b.textContent = '‚å´';
            b.style.marginLeft = '6px'; // Add space before DELETE
          } else {
            b.textContent = ch.toUpperCase();
          }
          
          // Enhanced event handling for better responsiveness
          let isPressed = false;
          
          // Mouse events
          b.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isPressed = true;
            addRippleEffect(b);
          });
          
          b.addEventListener('mouseup', () => {
            if (isPressed) {
              isPressed = false;
              handleKeyPress(ch);
            }
          });
          
          b.addEventListener('mouseleave', () => {
            isPressed = false;
          });
          
          // Touch events for mobile
          b.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isPressed = true;
            addRippleEffect(b);
            
            // Haptic feedback on supported devices
            if (navigator.vibrate) {
              navigator.vibrate(10);
            }
          }, { passive: false });
          
          b.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isPressed) {
              isPressed = false;
              handleKeyPress(ch);
            }
          }, { passive: false });
          
          b.addEventListener('touchcancel', () => {
            isPressed = false;
          });
          
          row.appendChild(b);
        }
      } else {
        // Top two rows - normal layout
        for (const ch of r) {
          const b = document.createElement('button'); 
          b.className = 'key';
          b.textContent = ch.toUpperCase();
          
          // Enhanced event handling for better responsiveness
          let isPressed = false;
          
          // Mouse events
          b.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isPressed = true;
            addRippleEffect(b);
          });
          
          b.addEventListener('mouseup', () => {
            if (isPressed) {
              isPressed = false;
              handleKeyPress(ch);
            }
          });
          
          b.addEventListener('mouseleave', () => {
            isPressed = false;
          });
          
          // Touch events for mobile
          b.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isPressed = true;
            addRippleEffect(b);
            
            // Haptic feedback on supported devices
            if (navigator.vibrate) {
              navigator.vibrate(10);
            }
          }, { passive: false });
          
          b.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isPressed) {
              isPressed = false;
              handleKeyPress(ch);
            }
          }, { passive: false });
          
          b.addEventListener('touchcancel', () => {
            isPressed = false;
          });
          
          row.appendChild(b);
        }
      }
      
      kbd.appendChild(row);
    }
  }

  function handleKeyPress(ch) {
    // Immediate visual feedback
    console.log('Key pressed:', ch);
    
    if (ch==='‚Üµ') {
      submitGuess();
    } else if (ch==='‚å´') {
      backspace();
    } else {
      typeChar(ch);
    }
  }

  function updateKeyStates() {
    const states = {}; const rank = {absent:0,present:1,correct:2};
    for (const g of GUESSES) {
      if (g.length !== ANSWER.length) continue;
      const tiles = scoreGuess(ANSWER,g);
      tiles.forEach((s,i) => {
        const c = g[i];
        if (!(c in states) || rank[s] > rank[states[c]]) states[c] = s;
      });
    }
    for (const btn of kbd.querySelectorAll('.key')) {
      const c = btn.textContent;
      if (!c || c.length!==1 || !/[a-z]/.test(c)) continue;
      btn.classList.remove('state-absent','state-present','state-correct');
      if (states[c]) btn.classList.add('state-'+states[c]);
    }
  }

  function renderBoard() {
    board.style.setProperty('--len', WORD_LEN);
    board.innerHTML = '';
    for (let r = 0; r < MAX_GUESSES; r++) {
      const row = document.createElement('div'); 
      row.className = 'row';
      const guess = GUESSES[r] || '';
      const isDone = r < GUESSES.length - 1 || (r < GUESSES.length && guess.length === WORD_LEN && !LOCKED);
      const tiles = isDone ? scoreGuess(ANSWER, guess) : [];
      
      for (let c = 0; c < WORD_LEN; c++) {
        const t = document.createElement('div'); 
        t.className = 'tile';
        t.textContent = guess[c] ? guess[c].toUpperCase() : '';
        if (isDone && guess.length === WORD_LEN) t.classList.add(tiles[c]); 
        row.appendChild(t);
      }
      board.appendChild(row);
    }
  }

  function seedIndex(seedStr, modulo) {
    let h = 2166136261 >>> 0;
    for (let i=0;i<seedStr.length;i++){ h ^= seedStr.charCodeAt(i); h = Math.imul(h, 16777619) >>> 0; }
    return modulo ? (h % modulo) : 0;
  }

  async function loadLists() {
    console.log(`Loading word lists for ${CURRENT_CATEGORY} length ${WORD_LEN}`);
    
    try {
      // Try to load answers file
      console.log(`Fetching: words/${CURRENT_CATEGORY}/answers-${WORD_LEN}.txt`);
      const answersResponse = await fetch(`words/${CURRENT_CATEGORY}/answers-${WORD_LEN}.txt`, { 
        cache: 'no-store',
        mode: 'cors' // Explicitly request CORS
      });
      
      if (!answersResponse.ok) {
        throw new Error(`HTTP ${answersResponse.status}: ${answersResponse.statusText} for answers file`);
      }
      
      const answerText = await answersResponse.text();
      console.log(`Answers file loaded, ${answerText.length} characters`);
      
      // Try to load allowed words file (optional)
      let allowedText = '';
      try {
        console.log(`Fetching: words/${CURRENT_CATEGORY}/allowed-${WORD_LEN}.txt`);
        const allowedResponse = await fetch(`words/${CURRENT_CATEGORY}/allowed-${WORD_LEN}.txt`, { 
          cache: 'no-store',
          mode: 'cors'
        });
        
        if (allowedResponse.ok) {
          allowedText = await allowedResponse.text();
          console.log(`Allowed words file loaded, ${allowedText.length} characters`);
        } else {
          console.warn(`Allowed words file not accessible: HTTP ${allowedResponse.status}`);
        }
      } catch (allowedError) {
        console.warn('Could not load allowed words file:', allowedError.message);
      }
      
      const sanitize = (txt) => [...new Set(txt.split(/\r?\n/).map(s => s.trim().toLowerCase()).filter(s => s.length===WORD_LEN && /^[a-z]+$/.test(s)))];
      ANSWERS = sanitize(answerText);
      ALLOWED = new Set(sanitize(allowedText).concat(ANSWERS));
      
      console.log(`Successfully loaded ${ANSWERS.length} answers and ${ALLOWED.size} allowed words for ${CURRENT_CATEGORY} length ${WORD_LEN}`);
      
      if (ANSWERS.length === 0) {
        throw new Error('No valid answers found in file');
      }
      
      // Clear any previous error messages
      if (msg.textContent.includes('Failed to load')) {
        msg.textContent = '';
      }
      
    } catch (e) {
      console.error('Failed to load word lists:', e);
      
      // Show detailed error information
      const errorDetails = e.message || 'Unknown error';
      const errorMessage = `‚ö†Ô∏è Cannot load ${CATEGORIES[CURRENT_CATEGORY]?.name} ${WORD_LEN}-letter word lists. 
      
Server Error: ${errorDetails}

This might be due to:
‚Ä¢ Server permissions blocking .txt files
‚Ä¢ CORS (Cross-Origin) restrictions
‚Ä¢ Network connectivity issues

Try refreshing the page or contact the site administrator.`;
      
      showErrorMessage(errorMessage);
      
      // Provide fallback - use a minimal word list to keep game functional
      console.log('Using emergency fallback word list');
      ANSWERS = ['hello', 'world', 'games', 'words', 'magic'].filter(w => w.length === WORD_LEN);
      if (ANSWERS.length === 0) {
        // Generate some basic words for the current length
        const fallbackWords = {
          5: ['hello', 'world', 'games', 'magic', 'flash', 'block', 'spark', 'swift'],
          6: ['wonder', 'bright', 'strong', 'simple', 'cosmic', 'blazer', 'frozen'],
          7: ['amazing', 'complex', 'freedom', 'journey', 'crystal', 'awesome'],
          8: ['magnetic', 'tropical', 'inspired', 'machines', 'galaxies'],
          9: ['wonderful', 'explosion', 'knowledge', 'adventures', 'sparkling'],
          10: ['incredible', 'mysterious', 'technology', 'imaginable', 'tremendous']
        };
        ANSWERS = fallbackWords[WORD_LEN] || ['error'.padEnd(WORD_LEN, 'x').slice(0, WORD_LEN)];
      }
      ALLOWED = new Set(ANSWERS);
      console.log(`Emergency fallback: ${ANSWERS.length} words available`);
    }
  }

  function getDailyPuzzleId() {
    const today = new Date();
    const iso = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate())).toISOString().slice(0,10);
    return `${iso}-${WORD_LEN}`;
  }

  function puzzleNumber(pid) {
    if (!pid.startsWith('20')) return '?';
    const epoch = new Date(cfg.dailyEpoch || '2024-01-01T00:00:00Z');
    const d = new Date(pid.slice(0,10)+'T00:00:00Z');
    const n = Math.floor((d - epoch) / 86400000);
    return n >= 0 ? n : '?';
  }

  function newPuzzle(mode) {
    GUESSES = []; LOCKED = false;
    let pid, idx;
    if (mode === 'random') {
      const rnd = Math.random().toString(36).slice(2,10);
      pid = `rnd-${rnd}-${WORD_LEN}-${CURRENT_CATEGORY}`;
      idx = seedIndex(`${rnd}:${WORD_LEN}:${CURRENT_CATEGORY}`, ANSWERS.length);
      console.log(`Random mode: rnd=${rnd}, category=${CURRENT_CATEGORY}, idx=${idx}, total=${ANSWERS.length}`);
    } else {
      pid = `${getDailyPuzzleId()}-${CURRENT_CATEGORY}`;
      idx = seedIndex(`${cfg.publicSeed}:${pid}`, ANSWERS.length);
      console.log(`Daily mode: pid=${pid}, seed=${cfg.publicSeed}, category=${CURRENT_CATEGORY}, idx=${idx}, total=${ANSWERS.length}`);
    }
    PUZZLE_ID = pid;
    ANSWER = ANSWERS[idx];
    console.log(`Selected answer: ${ANSWER} (index ${idx})`);
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    meta.textContent = ` ‚Ä¢ ${catName} ‚Ä¢ ${mode} ‚Ä¢ ${WORD_LEN}-letter ‚Ä¢ #${puzzleNumber(pid)}`;
    msg.textContent = '';
    renderBoard(); updateKeyStates();
    const s = loadStats(); getBucket(s, mode, WORD_LEN, CURRENT_CATEGORY); s[statsBucketKey(mode,WORD_LEN,CURRENT_CATEGORY)].lastPlayedPid = pid; saveStats(s); updateStatsUI();
  }

  function scoreGuess(answer, guess) {
    const n = answer.length, res = Array(n).fill('absent'), count = {};
    for (let i=0;i<n;i++) count[answer[i]] = (count[answer[i]]||0)+1;
    for (let i=0;i<n;i++) if (guess[i]===answer[i]) { res[i]='correct'; count[guess[i]]--; }
    for (let i=0;i<n;i++) if (res[i]!=='correct' && (count[guess[i]]||0)>0) { res[i]='present'; count[guess[i]]--; }
    return res;
  }

  function typeChar(ch) {
    if (LOCKED) return;
    if (!/^[a-z]$/i.test(ch)) return;
    
    // Always ensure we have a current guess row
    if (GUESSES.length === 0) {
      GUESSES.push('');
    }
    
    // If current row is full, create new row (unless we're at max guesses)
    if (GUESSES[GUESSES.length-1].length === WORD_LEN) {
      if (GUESSES.length >= MAX_GUESSES) return;
      GUESSES.push('');
    }
    
    const i = GUESSES.length-1;
    if (GUESSES[i].length < WORD_LEN) { 
      GUESSES[i] += ch.toLowerCase(); 
      renderBoard(); 
      
      // Check if word is now complete and provide feedback
      if (GUESSES[i].length === WORD_LEN) {
        console.log(`Word complete: "${GUESSES[i]}" - waiting for Enter key`);
        
        // Visual feedback that word is complete
        msg.textContent = `Word complete: "${GUESSES[i].toUpperCase()}" - Press ENTER ‚Üµ to submit!`;
        msg.style.color = '#6ca0ff';
        msg.style.fontWeight = 'bold';
        msg.style.backgroundColor = 'rgba(108, 160, 255, 0.1)';
        msg.style.padding = '8px';
        msg.style.borderRadius = '6px';
        msg.style.border = '1px solid #6ca0ff';
        
        // Make the Enter key pulse to draw attention
        const enterKey = document.querySelector('.key');
        const enterKeys = document.querySelectorAll('.key');
        for (const key of enterKeys) {
          if (key.textContent === '‚Üµ') {
            key.style.animation = 'pulse 1s infinite';
            key.style.background = '#6ca0ff';
            key.style.color = '#081424';
            break;
          }
        }
        
        // Add pulse animation if not exists
        if (!document.getElementById('pulse-animation')) {
          const style = document.createElement('style');
          style.id = 'pulse-animation';
          style.textContent = `
            @keyframes pulse {
              0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(108, 160, 255, 0.7); }
              70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(108, 160, 255, 0); }
              100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(108, 160, 255, 0); }
            }
          `;
          document.head.appendChild(style);
        }
      } else {
        // Clear any previous completion messages
        if (msg.textContent.includes('Press ENTER')) {
          msg.textContent = '';
          msg.style.cssText = '';
          
          // Reset Enter key styling
          const enterKeys = document.querySelectorAll('.key');
          for (const key of enterKeys) {
            if (key.textContent === '‚Üµ') {
              key.style.animation = '';
              key.style.background = '';
              key.style.color = '';
              break;
            }
          }
        }
      }
    }
  }
  function backspace() {
    if (LOCKED || GUESSES.length === 0) return;
    const i = GUESSES.length - 1;
    if (GUESSES[i].length === 0) {
      // If current row is empty, remove it if it's not the only row
      if (GUESSES.length > 1) {
        GUESSES.pop();
      }
      return;
    }
    GUESSES[i] = GUESSES[i].slice(0, -1);
    renderBoard();
    
    // Clear completion message and styling when word becomes incomplete
    if (GUESSES[i].length < WORD_LEN && msg.textContent.includes('Press ENTER')) {
      msg.textContent = '';
      msg.style.cssText = '';
      
      // Reset Enter key styling
      const enterKeys = document.querySelectorAll('.key');
      for (const key of enterKeys) {
        if (key.textContent === '‚Üµ') {
          key.style.animation = '';
          key.style.background = '';
          key.style.color = '';
          break;
        }
      }
    }
  }

  function finalizeGame(won) {
    console.log('finalizeGame called with won:', won); // Debug
    LOCKED = true;
    const s = loadStats();
    const b = getBucket(s, MODE, WORD_LEN, CURRENT_CATEGORY);

    // Count games only once per puzzleId (avoid F5 spam)
    const alreadyCounted = b._countedPid === PUZZLE_ID;
    if (!alreadyCounted) {
      b.games += 1;
      b._countedPid = PUZZLE_ID;
    }

    if (won && !b._wonPid?.includes(PUZZLE_ID)) {
      b.wins += 1;
      const today = todayISO();
      // streak only applies to daily mode
      if (MODE === 'daily') {
        if (b.lastWinDate) {
          const prev = new Date(b.lastWinDate+'T00:00:00Z');
          const cur = new Date(today+'T00:00:00Z');
          const diff = Math.round((cur - prev)/86400000);
          b.streak = diff === 1 ? (b.streak+1) : (diff === 0 ? b.streak : 1);
        } else {
          b.streak = 1;
        }
        b.lastWinDate = today;
      }
      b._wonPid = (b._wonPid || []).concat(PUZZLE_ID);
    } else if (!won && MODE === 'daily') {
      // a loss breaks streak for daily if played today
      const today = todayISO();
      const pidDay = PUZZLE_ID.slice(0,10);
      if (pidDay === today) b.streak = 0;
    }

    saveStats(s);
    updateStatsUI();
    
    console.log('About to call showGameDialog with won:', won); // Debug
    // Show win/lose dialog
    showGameDialog(won);
  }

  function showGameDialog(won) {
    console.log('showGameDialog called with won:', won); // Debug
    
    // Remove any existing dialogs first
    const existingOverlay = document.querySelector('.dialog-overlay');
    if (existingOverlay) {
      console.log('Removing existing dialog'); // Debug
      existingOverlay.remove();
    }
    
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    
    const dialog = document.createElement('div');
    dialog.className = 'dialog';
    
    const userName = loadUserName();
    const personalGreeting = userName ? ` ${userName}` : '';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    
    console.log('Creating dialog content for', won ? 'win' : 'lose'); // Debug
    
    if (won) {
      dialog.innerHTML = `
        <h2 class="win">üéâ Congratulations${personalGreeting}!</h2>
        <p>You solved today's ${catName} Wordle!</p>
        <div class="answer-word">${ANSWER.toUpperCase()}</div>
        <p>Solved in ${GUESSES.length} guess${GUESSES.length === 1 ? '' : 'es'}!</p>
        <button id="continueBtn" style="font-size:18px; padding:12px 24px;">Continue</button>
      `;
    } else {
      dialog.innerHTML = `
        <h2 class="lose">üòî Game Over${personalGreeting}</h2>
        <p>Better luck next time!</p>
        <div class="answer-word">${ANSWER.toUpperCase()}</div>
        <p>The word was <strong>${ANSWER.toUpperCase()}</strong></p>
        <button id="continueBtn" style="font-size:18px; padding:12px 24px;">Try Again Tomorrow</button>
      `;
    }
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    console.log('Dialog added to DOM'); // Debug
    
    // Add click handler to the button
    const continueBtn = dialog.querySelector('#continueBtn');
    continueBtn.addEventListener('click', () => {
      console.log('Continue button clicked'); // Debug
      overlay.remove();
    });
    
    // Ensure dialog is visible on mobile
    setTimeout(() => {
      console.log('Scrolling dialog into view'); // Debug
      dialog.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // Force focus on the button for mobile accessibility
      continueBtn.focus();
    }, 200);
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        console.log('Overlay clicked, closing dialog'); // Debug
        overlay.remove();
      }
    });
    
    // Close on Escape key
    const closeOnEscape = (e) => {
      if (e.key === 'Escape') {
        console.log('Escape pressed, closing dialog'); // Debug
        overlay.remove();
        document.removeEventListener('keydown', closeOnEscape);
      }
    };
    document.addEventListener('keydown', closeOnEscape);
    
    // Auto-close after 15 seconds if user doesn't interact (mobile fallback)
    const autoClose = setTimeout(() => {
      console.log('Auto-closing dialog after timeout'); // Debug
      if (document.body.contains(overlay)) {
        overlay.remove();
      }
    }, 15000);
    
    // Cancel auto-close if user clicks
    overlay.addEventListener('click', () => {
      clearTimeout(autoClose);
    });
    
    console.log('Dialog setup complete'); // Debug
    
    // Mobile fallback - Create GIANT full-screen notification 
    console.log('Creating GIANT mobile game completion notification'); // Debug
    setTimeout(() => {
      const alertMessage = won ? 
        `üéâ CONGRATULATIONS${personalGreeting}!<br><br>You solved today's ${catName} Wordle!<br><br><strong>${ANSWER.toUpperCase()}</strong><br><br>Solved in ${GUESSES.length} guess${GUESSES.length === 1 ? '' : 'es'}!` :
        `üòî GAME OVER${personalGreeting}<br><br>Better luck next time!<br><br>The word was:<br><strong>${ANSWER.toUpperCase()}</strong>`;
      
      const notification = document.createElement('div');
      notification.id = 'mobile-game-notification';
      notification.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        background: ${won ? 'rgba(76, 175, 80, 0.96)' : 'rgba(244, 67, 54, 0.96)'} !important;
        color: white !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        font-size: 24px !important;
        font-weight: bold !important;
        z-index: 99999 !important;
        text-align: center !important;
        padding: 40px !important;
        box-sizing: border-box !important;
        animation: slideIn 0.5s ease-out !important;
      `;
      
      // Add slide-in animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { opacity: 0; transform: scale(0.8); }
          to { opacity: 1; transform: scale(1); }
        }
      `;
      document.head.appendChild(style);
      
      notification.innerHTML = `
        <div style="
          background: white; 
          color: ${won ? '#4CAF50' : '#f44336'}; 
          padding: 40px; 
          border-radius: 25px; 
          max-width: 90vw; 
          font-size: 22px;
          border: 6px solid ${won ? '#4CAF50' : '#f44336'};
          box-shadow: 0 0 60px rgba(0,0,0,0.8);
          line-height: 1.5;
        ">
          ${alertMessage}
          <div style="margin-top: 30px; font-size: 18px; background: ${won ? '#4CAF50' : '#f44336'}; color: white; padding: 15px; border-radius: 15px;">
            üéØ TAP ANYWHERE TO CONTINUE üéØ
          </div>
        </div>
      `;
      
      // Remove any existing game notifications
      const existing = document.getElementById('mobile-game-notification');
      if (existing) existing.remove();
      
      document.body.appendChild(notification);
      console.log('GIANT mobile game notification added to DOM');
      
      // Click to close
      notification.addEventListener('click', () => {
        notification.remove();
        console.log('Giant mobile game notification clicked and removed');
      });
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (notification && notification.parentNode) {
          notification.remove();
          console.log('Giant mobile game notification auto-removed');
        }
      }, 10000);
      
      console.log('Giant game completion notification shown successfully');
    }, 500);
  }

  function showNameDialog() {
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    
    const dialog = document.createElement('div');
    dialog.className = 'dialog';
    
    const currentName = loadUserName();
    
    dialog.innerHTML = `
      <h2>üë§ Enter Your Name</h2>
      <p>Personalize your WillkeWorld Wordle Wonder experience!</p>
      <input type="text" id="nameInput" placeholder="Enter your name" value="${currentName}" maxlength="20">
      <div>
        <button onclick="saveName()">Save Name</button>
        <button onclick="this.closest('.dialog-overlay').remove()" style="margin-left:10px;">Cancel</button>
      </div>
    `;
    
    // Make saveName function available globally for the onclick
    window.saveName = () => {
      const nameInput = document.getElementById('nameInput');
      const name = nameInput.value.trim();
      if (name) {
        saveUserName(name);
        updateStatsUI();
        overlay.remove();
        showSuccessMessage(`Welcome, ${name}! üëã`);
      } else {
        nameInput.style.borderColor = '#ff6b6b';
        nameInput.focus();
      }
    };
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Focus the input
    setTimeout(() => {
      const input = document.getElementById('nameInput');
      input.focus();
      input.select();
    }, 100);
    
    // Handle Enter key in input
    dialog.querySelector('#nameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        window.saveName();
      } else if (e.key === 'Escape') {
        overlay.remove();
      }
    });
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        overlay.remove();
      }
    });
  }

  function showSuccessMessage(message) {
    console.log('‚úÖ showSuccessMessage called with:', message); // Success debug
    
    // IMMEDIATE visual feedback - positive title change
    document.title = '‚úÖ SUCCESS: ' + message;
    
    // Update the regular message area with positive styling
    msg.textContent = message;
    msg.classList.add('success-pulse');
    msg.style.color = '#4CAF50 !important'; // Green for success
    msg.style.backgroundColor = 'rgba(76, 175, 80, 0.1) !important'; // Light green background
    msg.style.padding = '12px !important';
    msg.style.borderRadius = '8px !important';
    msg.style.fontWeight = 'bold !important';
    msg.style.fontSize = '16px !important';
    msg.style.border = '2px solid #4CAF50 !important'; // Green border
    msg.style.zIndex = '999 !important';
    msg.style.position = 'relative !important';
    
    // Force visibility
    msg.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    // FRIENDLY mobile notification - iOS-style overlay
    console.log('üì± Creating iOS-style mobile success notification'); // Debug
    const notification = document.createElement('div');
    notification.id = 'mobile-success-notification';
    notification.className = 'success-notification';
    notification.style.cssText = `
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      background: rgba(0, 0, 0, 0.8) !important;
      backdrop-filter: blur(10px) !important;
      -webkit-backdrop-filter: blur(10px) !important;
      color: white !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      font-size: 28px !important;
      font-weight: bold !important;
      z-index: 999999 !important;
      text-align: center !important;
      padding: 40px !important;
      box-sizing: border-box !important;
      animation: fadeInScale 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
      cursor: pointer !important;
    `;
    
    // Add iOS-style animations
    const style = document.createElement('style');
    style.id = 'success-animations';
    style.textContent = `
      @keyframes fadeInScale {
        0% { opacity: 0; transform: scale(0.8); }
        100% { opacity: 1; transform: scale(1); }
      }
      @keyframes success-pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
      }
      .success-pulse {
        animation: success-pulse 0.6s ease-in-out !important;
      }
    `;
    if (!document.getElementById('success-animations')) {
      document.head.appendChild(style);
    }
    
    notification.innerHTML = `
      <div style="
        background: linear-gradient(135deg, #4CAF50, #45a049); 
        color: white; 
        padding: 48px 32px; 
        border-radius: 24px; 
        max-width: 85vw; 
        font-size: 24px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.1);
        animation: cardBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        position: relative;
        overflow: hidden;
      ">
        <div style="
          position: absolute; 
          top: 0; 
          left: -100%; 
          width: 100%; 
          height: 100%; 
          background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
          animation: shine 1.5s ease-out;
        "></div>
        <div style="font-size: 48px; margin-bottom: 16px; filter: drop-shadow(0 2px 8px rgba(0,0,0,0.3));">‚úÖ</div>
        <div style="font-weight: 700; font-size: 22px; margin-bottom: 8px;">SUCCESS</div>
        <div style="font-weight: 400; font-size: 18px; opacity: 0.95; line-height: 1.4;">
          ${message}
        </div>
        <div style="margin-top: 24px; font-size: 14px; opacity: 0.8; background: rgba(255,255,255,0.15); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.2);">
          Tap anywhere to continue
        </div>
      </div>
    `;
    
    // Remove any existing success notifications
    const existing = document.getElementById('mobile-success-notification');
    if (existing) {
      console.log('üóëÔ∏è Removing existing success notification');
      existing.remove();
    }
    
    document.body.appendChild(notification);
    console.log('‚úÖ SUCCESS mobile notification added to DOM');
    
    // Click to dismiss
    notification.addEventListener('click', () => {
      console.log('üëÜ Success notification clicked, removing');
      notification.remove();
      document.title = 'WillkeWorld Wordle Wonder'; // Reset title
    });
    
    // Keyboard dismiss
    const dismissOnKey = (e) => {
      console.log('‚å®Ô∏è Key pressed, dismissing success notification');
      notification.remove();
      document.title = 'WillkeWorld Wordle Wonder'; // Reset title
      document.removeEventListener('keydown', dismissOnKey);
    };
    document.addEventListener('keydown', dismissOnKey);
    
    // Auto-remove after 3 seconds (shorter for positive messages)
    setTimeout(() => {
      if (notification && notification.parentNode) {
        console.log('‚è±Ô∏è Auto-removing success notification after timeout');
        notification.remove();
        document.title = 'WillkeWorld Wordle Wonder'; // Reset title
      }
    }, 3000);
    
    setTimeout(() => {
      msg.classList.remove('success-pulse');
      msg.style.cssText = ''; // Reset all styles at once
    }, 4000);
    
    console.log('üéØ showSuccessMessage function complete');
  }

  function showErrorMessage(message) {
    console.log('üö® showErrorMessage called with:', message); // Enhanced debug
    
    // IMMEDIATE visual feedback - force browser attention
    document.title = 'üö® ERROR: ' + message;
    
    // Update the regular message area
    msg.textContent = message;
    msg.classList.add('error-shake');
    msg.style.color = '#ff6b6b !important'; // Make error more visible
    msg.style.backgroundColor = 'rgba(255, 107, 107, 0.9) !important'; // Stronger background
    msg.style.padding = '12px !important';
    msg.style.borderRadius = '8px !important';
    msg.style.fontWeight = 'bold !important';
    msg.style.fontSize = '16px !important'; // Larger text for mobile
    msg.style.border = '2px solid #ff6b6b !important'; // Border for visibility
    msg.style.zIndex = '999 !important'; // Ensure it's on top
    msg.style.position = 'relative !important';
    
    // Force visibility on mobile with multiple methods
    msg.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    // Mobile-specific: Force repaint
    msg.style.transform = 'translateZ(0)';
    msg.offsetHeight; // Force reflow
    
    // Try native alert as backup (in case DOM manipulation is being blocked)
    try {
      alert('üö® ERROR: ' + message);
      console.log('‚úÖ Native alert shown successfully');
    } catch (e) {
      console.log('‚ùå Native alert blocked:', e);
    }
    
    // SUPER PROMINENT mobile notification - iOS-style error overlay
    console.log('üì± Creating iOS-style mobile error notification overlay'); // Debug
    const notification = document.createElement('div');
    notification.id = 'mobile-notification';
    notification.className = 'emergency-notification'; // Add class for debugging
    notification.style.cssText = `
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      background: rgba(0, 0, 0, 0.85) !important;
      backdrop-filter: blur(12px) !important;
      -webkit-backdrop-filter: blur(12px) !important;
      color: white !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      font-size: 28px !important;
      font-weight: bold !important;
      z-index: 999999 !important;
      text-align: center !important;
      padding: 40px !important;
      box-sizing: border-box !important;
      animation: fadeInScale 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
      cursor: pointer !important;
    `;
    
    // Add iOS-style animations
    const style = document.createElement('style');
    style.id = 'error-animations';
    style.textContent = `
      @keyframes fadeInScale {
        0% { opacity: 0; transform: scale(0.8); }
        100% { opacity: 1; transform: scale(1); }
      }
      @keyframes cardBounce {
        0% { transform: translateY(30px) scale(0.9); opacity: 0; }
        100% { transform: translateY(0) scale(1); opacity: 1; }
      }
      @keyframes shine {
        0% { left: -100%; }
        100% { left: 100%; }
      }
      @keyframes errorPulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
      }
    `;
    if (!document.getElementById('error-animations')) {
      document.head.appendChild(style);
    }
    
    notification.innerHTML = `
      <div style="
        background: linear-gradient(135deg, #ff4444, #cc3333); 
        color: white; 
        padding: 48px 32px; 
        border-radius: 24px; 
        max-width: 85vw; 
        font-size: 22px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.1);
        animation: cardBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        position: relative;
        overflow: hidden;
        line-height: 1.4;
      ">
        <div style="
          position: absolute; 
          top: 0; 
          left: -100%; 
          width: 100%; 
          height: 100%; 
          background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
          animation: shine 1.5s ease-out;
        "></div>
        <div style="font-size: 48px; margin-bottom: 16px; filter: drop-shadow(0 2px 8px rgba(0,0,0,0.3));">‚ö†Ô∏è</div>
        <div style="font-weight: 700; font-size: 20px; margin-bottom: 12px;">ERROR</div>
        <div style="font-weight: 400; font-size: 16px; opacity: 0.95; line-height: 1.5; white-space: pre-line;">
          ${message}
        </div>
        <div style="margin-top: 24px; font-size: 14px; opacity: 0.8; background: rgba(255,255,255,0.15); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.2);">
          Tap anywhere to dismiss
        </div>
      </div>
    `;
    
    // Remove any existing notifications
    const existing = document.getElementById('mobile-notification');
    if (existing) {
      console.log('üóëÔ∏è Removing existing notification');
      existing.remove();
    }
    
    document.body.appendChild(notification);
    console.log('‚úÖ GIANT mobile notification added to DOM, element:', notification);
    console.log('‚úÖ Notification parent:', notification.parentNode);
    console.log('‚úÖ Notification computed style:', window.getComputedStyle(notification).display);
    
    // Multiple ways to ensure visibility
    notification.scrollIntoView({ behavior: 'instant', block: 'center' });
    
    // Click to dismiss
    notification.addEventListener('click', () => {
      console.log('üëÜ Notification clicked, removing');
      notification.remove();
      document.title = 'WillkeWorld Wordle Wonder'; // Reset title
    });
    
    // Keyboard dismiss
    const dismissOnKey = (e) => {
      console.log('‚å®Ô∏è Key pressed, dismissing notification');
      notification.remove();
      document.title = 'WillkeWorld Wordle Wonder'; // Reset title
      document.removeEventListener('keydown', dismissOnKey);
    };
    document.addEventListener('keydown', dismissOnKey);
    
    // Auto-remove after 6 seconds (longer for readability)
    setTimeout(() => {
      if (notification && notification.parentNode) {
        console.log('‚è±Ô∏è Auto-removing notification after timeout');
        notification.remove();
        document.title = 'WillkeWorld Wordle Wonder'; // Reset title
      }
    }, 6000);
    
    setTimeout(() => {
      msg.classList.remove('error-shake');
      msg.style.cssText = ''; // Reset all styles at once
    }, 7000); // Longer duration for mobile
    
    console.log('üéØ showErrorMessage function complete');
  }

  function submitGuess() {
    console.log('submitGuess called, LOCKED:', LOCKED, 'GUESSES.length:', GUESSES.length); // Debug
    if (LOCKED || GUESSES.length === 0) return;
    const i = GUESSES.length - 1;
    const g = GUESSES[i];
    
    console.log('Submitting guess:', g, 'length:', g.length, 'required:', WORD_LEN); // Debug
    
    // Must have exactly WORD_LEN letters
    if (g.length !== WORD_LEN) { 
      console.log('Not enough letters'); // Debug
      showErrorMessage('Not enough letters.');
      return; 
    }
    
    console.log('Checking if allowed:', g, 'in set:', ALLOWED.has(g)); // Debug
    
    // Must be a valid dictionary word
    if (!ALLOWED.has(g)) { 
      console.log('Invalid word detected:', g); // Debug
      showErrorMessage(`"${g.toUpperCase()}" is not a valid word! Clearing...`);
      // Clear the invalid word immediately and re-render
      GUESSES[i] = '';
      console.log('Cleared guess, re-rendering'); // Debug
      renderBoard();
      // Force a brief pause to show the error message
      setTimeout(() => {
        console.log('Second render after clear'); // Debug
        renderBoard(); // Re-render to ensure UI is updated
      }, 200);
      return; 
    }

    console.log('Valid word, processing guess'); // Debug
    // Score the guess and update display
    const tiles = scoreGuess(ANSWER, g);
    renderBoard(); 
    updateKeyStates();
    const win = tiles.every(t => t === 'correct');

    console.log(`Guess ${GUESSES.length}: "${g}", Win: ${win}, Max: ${MAX_GUESSES}`);

    if (win) { 
      msg.textContent = 'You win! üéâ'; 
      console.log('Player won, calling finalizeGame(true)'); // Debug
      finalizeGame(true); 
      return; 
    }
    
    // Check if this was the last allowed guess
    if (GUESSES.length >= MAX_GUESSES) {
      console.log(`Game over! Final guess count: ${GUESSES.length}, Max: ${MAX_GUESSES}, Answer: ${ANSWER}`);
      msg.textContent = `Out of guesses. The word was ${ANSWER.toUpperCase()}.`;
      finalizeGame(false);
      return;
    }
    
    // Clear message for next guess
    msg.textContent = '';
  }

  async function shareResult() {
    if (GUESSES.length === 0) {
      msg.textContent = 'Play a game first before sharing!';
      return;
    }
    
    const rows = GUESSES.slice(0, Math.min(GUESSES.length, MAX_GUESSES));
    const squares = rows.map(g => scoreGuess(ANSWER,g).map(x => x==='correct'?'üü©': x==='present'?'üü®':'‚¨õ').join('')).join('\n');
    const won = rows.length>0 && scoreGuess(ANSWER, rows[rows.length-1]).every(x=>x==='correct');
    const attempts = won ? rows.length : 'X';
    const catName = CATEGORIES[CURRENT_CATEGORY]?.name || CURRENT_CATEGORY;
    const text = [
      `${catName} Wordle ${puzzleNumber(PUZZLE_ID)} ${attempts}/${MAX_GUESSES}`,
      '',
      squares
    ].join('\n');
    
    console.log('Sharing text:', text);
    
    try {
      // Try modern clipboard API first
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text); 
        msg.textContent = 'Copied result to clipboard ‚úÖ Ready to paste!'; 
        return;
      }
      
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      if (document.execCommand('copy')) {
        msg.textContent = 'Copied result to clipboard ‚úÖ Ready to paste!';
      } else {
        throw new Error('execCommand failed');
      }
      document.body.removeChild(textArea);
      
    } catch (err) {
      console.error('Share failed:', err);
      msg.textContent = `Share failed. Try manually copying: ${text}`;
    }
  }

  // Enhanced keyboard handling for mobile
  window.addEventListener('keydown', (e) => {
    // Don't handle keyboard events when a dialog is open or when typing in an input field
    if (document.querySelector('.dialog-overlay') || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return;
    }
    
    if (e.key==='Enter') {
      e.preventDefault(); // Prevent form submission on mobile
      handleKeyPress('‚Üµ');
    }
    else if (e.key==='Backspace') {
      e.preventDefault(); // Prevent navigation on mobile
      handleKeyPress('‚å´');
    }
    else if (/^[a-z]$/i.test(e.key)) {
      handleKeyPress(e.key.toLowerCase());
    }
  });

  // Optimized mobile touch event handling
  let touchStartY = 0;
  let touchEndY = 0;
  let touchStartX = 0;
  let touchEndX = 0;
  let isScrolling = false;
  
  // Only handle document-level touch events, not keyboard-specific ones
  document.addEventListener('touchstart', (e) => {
    // Skip if touch is on keyboard
    if (e.target.closest('.kbd')) {
      return;
    }
    
    touchStartY = e.changedTouches[0].screenY;
    touchStartX = e.changedTouches[0].screenX;
    isScrolling = false;
  }, { passive: true });
  
  document.addEventListener('touchmove', (e) => {
    // Skip if touch is on keyboard
    if (e.target.closest('.kbd')) {
      return;
    }
    
    isScrolling = true;
  }, { passive: true });
  
  document.addEventListener('touchend', (e) => {
    // Skip if touch is on keyboard
    if (e.target.closest('.kbd')) {
      return;
    }
    
    touchEndY = e.changedTouches[0].screenY;
    touchEndX = e.changedTouches[0].screenX;
    
    // Only prevent pull-to-refresh if at top of page and pulling down
    const deltaY = touchEndY - touchStartY;
    if (deltaY > 50 && window.scrollY <= 0 && !isScrolling) {
      e.preventDefault();
    }
  }, { passive: false });

  // iOS-specific optimizations
  if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
    // Prevent zoom on double tap
    document.addEventListener('touchend', function(e) {
      const now = new Date().getTime();
      const timeSince = now - lastTouchEnd;
      
      if ((timeSince < 300) && (timeSince > 0)) {
        e.preventDefault();
      }
      
      lastTouchEnd = now;
    }, false);
    
    // Disable selection on iOS
    document.addEventListener('selectstart', function(e) {
      e.preventDefault();
    });
    
    // Enhanced viewport handling for iOS
    const viewport = document.querySelector('meta[name="viewport"]');
    if (viewport) {
      viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no';
    }
  }
  
  let lastTouchEnd = 0;

  // boot
  renderKeyboard();
  await loadLists();
  newPuzzle(MODE);
  updateStatsUI();
  
  // Show name dialog on first visit if no name is set
  if (!loadUserName()) {
    setTimeout(() => {
      showNameDialog();
    }, 500); // Reduced delay from 1000ms to 500ms
  }
})();
</script>
</body>
</html>
